#
#	.kshsccs - ksh SCCS helpers
#
# Written by Greg A. Woods <woods@robohack.{UUCP,ca}> <woods@planix.{com,ca}>
#
#ident	"@(#)HOME:.kshsccs	22.1	01/10/17 12:09:45 (woods)"
#
# Copyright (c) 2001 Greg A. Woods
# 
# Redistribution of this software in both source and binary forms, with
# or without modification, is permitted provided that all of the
# following conditions are met:
# 
# 1. Redistributions of source code, either alone or as part of a
#    collective work, must retain this entire copyright notice, and the
#    following disclaimer, without alteration, in each file that
#    contains part of this software.
# 
# 2. Redistributions of this software in binary form, either alone or
#    as part of a collective work, must reproduce this entire copyright
#    notice, and the following disclaimer, without alteration, in
#    either the documentation (as text files in electronic media, or in
#    printed matter), and/or any original header files from this
#    software as per the previous term, and/or other materials provided
#    as part of the distribution.
# 
# 3. Collective works including this software must also include the
#    following acknowledgement, either alone or as part of this entire
#    copyright license, in any printed documentation accompanying a
#    physical distribution (if there is printed documentation), and in
#    a plain text file separate from the archive files (but perhaps
#    along with other similar acknowledgments) on any electronic
#    medium:
# 
# 	This product includes software developed by Greg A. Woods.
# 
# 4. The name of the author may NOT be used to endorse or promote
#    products derived from this software without specific prior written
#    permission.  The use of the author's name strictly to meet the
#    requirements of the previous terms is not to be considered
#    promotion or endorsement under this term.
# 
# 5. Altered versions (derivative works) must be plainly marked as
#    such, and must not be misrepresented as being the original
#    software.  This copyright notice, and the following disclaimer,
#    must not be removed from any derivative work and must not be
#    changed in any way.
# 
# All other rights are reserved.
# 
# DISCLAIMER:
# 
# THIS SOFTWARE IS PROVIDED BY GREG A. WOODS ``AS IS'' AND ANY EXPRESS
# OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
# GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
# IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
# IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# These aliases and functions provide some release and configuration
# management functions over and above sccs(1).  They are useful for small
# single-directory projects, but do not (yet) incorporate any recursive
# directory traversal functionality.
#
# There's no support (yet) for handling file deletion (and re-adding).
#
# There's no support for importing (eg. 3rd-party source) yet.
#
# WARNING:  There are some non-obvious caveats, assumptions, and limitations!
#
# For example, branches are not really supported, other than by careful
# use of '-t' to the right commands, though not all functions accept this
# option.
#
# Many of things should probably be separate scripts.....

# explicitly setting this makes life easier....
#
if [ -z "$PROJECT" ] ; then
	export PROJECT=SCCS
fi

# TODO: if the 'x' bit is set on the SCCS file, set it on the g-file too

alias vadmin='sccs -p $PROJECT admin'
alias vcdc='sccs -p $PROJECT cdc'
alias vcheck='sccs -p $PROJECT check'
alias vclean='sccs -p $PROJECT clean'
alias vcreate='sccs -p $PROJECT create'
alias vdeled='sccs -p $PROJECT deledit'
alias vdeledit='sccs -p $PROJECT deledit'
alias vdelget='sccs -p $PROJECT delget'
alias vdelta='sccs -p $PROJECT delta'
alias vdiff='sccs -p $PROJECT diffs'
alias vedit='sccs -p $PROJECT edit'
alias venter='sccs -p $PROJECT enter' # XXX should this warn to use vmksccs instead?
alias vfix='sccs -p $PROJECT fix'
alias vget='sccs -p $PROJECT get'
alias vgeted='sccs -p $PROJECT edit'
alias vgetedit='sccs -p $PROJECT edit'
alias vhelp='sccs help'
alias vinfo='sccs -p $PROJECT info'
alias vlog='sccs -p $PROJECT prs'
alias vnoproj='unset PROJECTDIR; vproj SCCS'
alias vprint='sccs -p $PROJECT print'
alias vprs='sccs -p $PROJECT prs'
alias vprt='sccs -p $PROJECT prt'
alias vrdiff='sccs -p $PROJECT sccsdiff'
alias vrmdel='sccs -p $PROJECT rmdel'
alias vsccsdiff='sccs -p $PROJECT sccsdiff'
alias vtell='sccs -p $PROJECT tell'
alias vunedit='sccs -p $PROJECT unedit'
alias vunget='sccs -p $PROJECT unget'
alias vval='sccs -p $PROJECT val'
alias vpident='echo "#ident	\"%Z\045%Y\045:%M\045	%I\045	%E\045 %U\045 (%Q\045)\""'

#
#	vproj - set project name
#
function vproj
{
	if [ $# -gt 1 ] ; then
		echo "Usage: $0 project-name" >&2
		return 2
	fi
	case "$1" in
	-*)
		echo "Usage: $0 project-name" >&2
		return 2
		;;
	esac
	if [ -n "${PROJECTDIR}" ] ; then
		eval TRYHOME="~${PROJECTDIR}"
		if [ -d ${TRYHOME}/src/${1}/SCCS ] ; then
			export PROJECT=${1}/SCCS
		elif [ -d ${TRYHOME}/source/${1}/SCCS ] ; then
			export PROJECT=${1}/SCCS
		else
			export PROJECT=${1}
		fi
		unset TRYHOME
	else
		export PROJECT=${1}
	fi
}

#
#	vprojdir - set project directory
#
function vprojdir
{
	if [ $# -ne 1 ] ; then
		echo "Usage: $0 project-directory | project-owner" >&2
		return 2
	fi
	case "$1" in
	"")
		unset PROJECTDIR
		;;
	-*)
		echo "Usage: $0 project-name | project-owner" >&2
		return 2
		;;
	*)
		export PROJECTDIR=${1}
		;;
	esac
}

#
#	vwproj - display project directory
#
function vwproj
{
	# should mimic how sccs(1) finds things....  From the manual:
	#
	# If the environment variable PROJECTDIR is set to contain  an
	# absolute  pathname  (beginning  with a slash), sccs searches
	# for SCCS history files in the directory given by that  vari-
	# able.  If PROJECTDIR does not begin with a slash, it is tak-
	# en as the name of a user,  and  sccs  searches  the  src  or
	# source subdirectory of that user's home directory for histo-
	# ry files. 
	#
	# Note though that vproj may set PROJECT to be $1/SCCS
	#
	case "${PROJECTDIR}" in
	"")
		echo $PROJECT
		;;
	/*)
		echo ${PROJECTDIR}/${PROJECT}
		;;
	*)
		eval TRYHOME="~${PROJECTDIR}"
		if [ -d ${TRYHOME}/src/${PROJECT}/SCCS ] ; then
			echo ${TRYHOME}/src/${PROJECT}/SCCS
		elif [ -d ${TRYHOME}/source/${PROJECT}/SCCS ] ; then
			echo ${TRYHOME}/source/${PROJECT}/SCCS
		elif [ -d ${TRYHOME}/src/${PROJECT} ] ; then
			echo ${TRYHOME}/src/${PROJECT}
		elif [ -d ${TRYHOME}/source/${PROJECT} ] ; then
			echo ${TRYHOME}/source/${PROJECT}
		fi
		unset TRYHOME
		;;
	esac
}

#
#	mksccs - create a new s-file with approprate flags
#
# based on:
#ident	"mksccs.sh,v 1.9 1993/01/18 22:25:14 woods Exp "
#
alias vmksccs=mksccs
function mksccs
{
	USAGE="Usage: $0 [-rSID] [-dDEFBR] file ..."
	DEFBR=""
	REL=""
	lastrel=$(vlastrel 2>/dev/null)
	if [ -n "$lastrel" ] ; then
		REL="-r$lastrel"
	fi
	while getopts d:r: OPTCH
	do
	  	case $OPTCH in
		d)
			DEFBR="-fd${OPTARG}"
			;;
		r)
			REL="-r${OPTARG}"
			;;
		*)
			echo $USAGE >&2
			return 2
			;;
		esac
	done
	shift $(( $OPTIND - 1 ))
	if [ $# -lt 1 ] ; then
		echo $USAGE >&2
		return 2
	fi
	# we don't really use "$sdir" -- we only want to be sure it exists
	# and if it doesn't then we'll create it now....
	sdir="$(vwproj)"
	if [ -z "$sdir" ] ; then
		echo "$0: no project set!" >&2
		return 1
	fi
	if [ ! -d "$sdir" ] ; then
		mkdir $sdir
	fi
	if [ ! -d "$sdir" ] ; then
		return 1
	fi

	# safer than $LOGNAME or $USER, so long as you have id(1)...
	mksccsuid=$(id | sed -e 's/^uid=[0-9]*(\(.*\)) gid=.*/\1/')

	# XXX this should be PROJECTDIR iff is a username
	if [ -z "$PROJOWNER" ] ; then
		QFLAG="$mksccsuid"
	else
		QFLAG="$PROJOWNER"
	fi

	if [ "$PROJECT" = "SCCS" ] ; then
		TFLAG=$(basename $(pwd))
	else
		TFLAG=$PROJECT
	fi
	sccs -p $PROJECT enter $REL $*
	if [ $? -eq 0 ] ; then
		sccs -p $PROJECT admin $DEFBR -fb -fq"$QFLAG" -ft"$TFLAG" $*
	else
		return 1
	fi

	rc=$?

	if sccs -p $PROJECT val $* ; then
		: # It's OK Jim....
	else
		echo "$0: failed to enter one or more files (try vval...)" >&2
		return 1
	fi

	sccs -p $PROJECT get $*

	rc=$(( $rc + $? ))

	if [ $rc -eq 0 ] ; then
		# pretty sure of ourselves!  :-)
		/bin/rm -f ,*
	fi

	unset DEFBR REL sdir QFLAG mksccsuid TFLAG
	return $rc
}

#
#	vverify - check that all the files in the project are present
#
function vverify
{
	sdir="$(vwproj)"
	for file in ${sdir}/s.* ; do
		if [ ! -r $(echo ${file} | sed "s#${sdir}/s.##") ] ; then
			echo ${file}
        	fi
	done
	unset sdir file
}


#
#	vlist - print interesting info about s-files
#
function vlist
{
	PRSLIST=":Z::Y:\::M:\t:I:\t(:Q:)\t:D: :T: :P:\tBF=:BF: MF=:MF:"
	# work around some silly pdksh bug....
	if  expr "$PRSLIST" : '.*\\' > /dev/null ; then
		PRSLIST=":Z::Y:::M:\t:I:\t(:Q:)\t:D: :T: :P:\tBF=:BF: MF=:MF:"
	fi
	if [ "$1" = "-m" ] ; then
		PRSLIST="$PRSLIST :MR:"
		shift
	fi
	sccs -p $PROJECT prs -d"$PRSLIST" ${1+"$@"} $PROJECT
	unset PRSLIST
}

#
#	vls - do ls in ${PROJECTDIR} with optional ls options
#
function vls
{
	ls $* $(vwproj)
}

#
#	vfiles - generate a list of project files
#
function vfiles
{
	ls $(vwproj) | awk '/^s\./{print substr($1, 3)}'
}

#
#	vwhat - a saner version of what
#
function vwhat
{
	if [ $# -eq 0 ] ; then
		echo "Usage: $0 file ..." >&2
		return 2
	fi

	what $* | awk 'NF > 1 {print $0}' | sort -u
}

#
#	vsact - wrapper for sact (you probably want vinfo instead!)
#
function vsact
{
	if [ $# -eq 0 ] ; then
		sccs -p $PROJECT sact $(vwproj)/s.*
	else
		sccs -p $PROJECT sact $*
	fi
}

#
#	vlastrel - guess last release
#
function vlastrel
{
	if [ $# -ne 0 ] ; then
		echo "Usage: $0" >&2
		return 2
	fi
	somefile=$(ls -f $(vwproj) | awk '/^s\./{print substr($1, 3); exit}')
	if [ -n "$somefile" ] ; then
		vprs -d:R: $somefile
	else
		echo "1"
	fi
}

#
#	vnewrel - start a new release
#
# (i.e. roll up the release number on all files in the project)
#
# WARNING:  Note there's no "module" locking here!
#
function vnewrel
{
	USAGE="Usage: $0 [RELEASE]"
	if [ -n "$(vtell)" ] ; then
		echo "$0: files still being edited!." >&2
		return 1
	fi
	if [ $# -eq 1 ] ; then
		REL=$1
		# XXX error check that it's an integer?
	elif [ $# -eq 0 ] ; then
		REL=$(( $(vlastrel) + 1 ))
	else
		echo "$USAGE" >&2
		return 2
	fi
	vedit -r$REL $PROJECT
	vdelget -y"START RELEASE $REL" $PROJECT
}
