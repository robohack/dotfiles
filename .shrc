#
#	.shrc - per-shell startup stuff for all shells
#
# Note:  Most of this should be compatible with some pre-POSIX shells.  Notably:
#
#	- mostly don't use $() for command expansion
#	- don't use '!' in test expressions for flow-control statements
#	- mostly no arithmetic expressions
#	- mostly no suffix or prefix patterns
#	- don't use ~ for pathname expansion (use $HOME)
#	- don't use "export VAR=value"
#
# It may also assume .profile has already set some things, though it should not.
# For the most part variables that are used herein should be set herein.
#
# Maybe even more environment variable settings should move here, especially any
# that are only used by functions here, e.g. as was done with MAILLOG
# (e.g. $PAGER).
#
#ident	"@(#)HOME:.shrc	37.34	24/06/08 16:03:00 (woods)"

if [ -z "${SHELL}" ]; then
	# likely plain old Bourne (heirloom) shell
	# XXX too bad we can't get the true full pathname
	SHELL=`expr "$0" : '-*\(.*\)'`
fi

# This file sets D_PS1 once done to allow setaliases to avoid clobbering
# .kshrc's new value.
#
if [ -z "${D_PS1}" ]; then
	# N.B.:  this will be possibly reset, then appended to....
	PS1=""
fi

# PS2="> "
# PS3="#? "
# PS4="+ "

is_bash ()
{
	[ ${RANDOM:-0} -ne ${RANDOM:-0} -a -n "${BASH}" ]
}

is_ksh ()
{
	if [ ${RANDOM:-0} -ne ${RANDOM:-0} -a -z "${BASH}" ]; then
		case "${KSH_VERSION}" in
		"Version"*)
			return 0 # likely att ksh
			;;
		"@(#)MIRBSD"*)
			return 0 # mksh
			;;
		"@(#)"*)
			return 0 # likely pdksh or some other derivative
			;;
		*)
			return 1
			;;
		esac
	else
		return 1
	fi
}

is_attksh ()
{
	is_bash && return 1

	# ksh93 and [p]bosh
	_sh_version=`eval 'echo "${.sh.version}"' 2>/dev/null`
	# [p]bosh only
	_sh_shell=`eval 'echo "${.sh.shell}"' 2>/dev/null`

	test -n "${_sh_version}" -a -z "${_sh_shell}"
	_rc=$?
	unset _sh_shell _sh_version

	return ${_rc}
}

is_ash ()
{
	is_ksh && return 1
	is_bash && return 1
	# older Ash didn't have $RANDOM?
	[ "`echo ~`" = "${HOME}" ]
}

is_bourne_sh ()
{
	is_ash && return 1
	[ "`echo ~`" != "${HOME}" -a -z "${RANDOM}" ]
}

is_posixish_sh ()
{
	[ "`echo ~`" = "${HOME}" -a ${RANDOM:-0} -eq ${RANDOM:-0} ]
}

is_schily_sh ()
{
	_sh_shell=`eval 'echo "${.sh.shell}"' 2>/dev/null`

	test -n "${_sh_shell}"
	_rc=$?
	unset _sh_shell

	return ${_rc}
}

ISSUN=false
if [ -x /usr/bin/sun ]; then
	if sun; then
		ISSUN=true
	fi
fi

if [ -r /var/log/smail/logfile ] ; then
	MAILLOG="/var/log/smail/logfile"
elif [ -r ${LOCAL}/var/log/smail/logfile ] ; then
	MAILLOG=${LOCAL}/var/log/smail/logfile
else
	MAILLOG="/var/log/smail/logfile"
fi
export MAILLOG

# always use ``$echo'' if any of the other variables are used...
#	$nl - print a newline (always required at end of line if desired)
#	$n - option to turn off final newline
#	$c - escape sequence to turn off final newline
# usage for a prompt is:
#	$echo $n "prompt: $c"
# and for a normal line
#	$echo "message$nl"
#
# Don't pretend to have print or printf if they are not builtin
#
HAVEPRINT=false
if expr "`type print 2>/dev/null`" : '^print is a shell ' > /dev/null 2>&1 ; then
	HAVEPRINT=true
fi
HAVEPRINTF=false
if expr "`type printf 2>/dev/null`" : '^printf is a shell ' > /dev/null 2>&1 ; then
	HAVEPRINTF=true
fi
if ${HAVEPRINT} ; then
	#
	# XXX Ksh "print" is a horrible mess of unusability, but, if it is
	# builtin....
	#
	# XXX in theory "print -R", if available, is a better emulation of BSD
	# echo with '-n', but for $echo it doesn't really matter....
	#
	echo=print
	nl='\n'
	n='-n'
	# XXX in theory '\c' is equivalent of '-n' in all Ksh-compatible shells
	c=''
elif ${HAVEPRINTF} ; then
	echo=printf
	nl='\n'
	n=''
	c=''
	# for fun:
	portable_echo ()
	{
		[ "$1" = -n ] && { shift; FMT="%s"; } || FMT="%s\n"
		printf "$FMT" ${1+"${@}"}
	}
else
	# NOTE:  Assume if "echo" is builtin that it is OK and do not prefer an
	# external "echo" for $echo, even if that is more capable (though that
	# is not likely ever true).
	#
	echo=echo
	c=`echo "xyzzy\c" | sed 's/[^c]//g'`
	if test -n "${c}" ; then
		# BSD echo
		nl=''
		n='-n'
		c=''
	else
		# (SysVr2 or newer) Bourne Shell echo
		# (some may have -n, but ignore that as we know we have '\c')
		nl='\n'
		n=''
		c='\c'
	fi
	# n.b.:  ancient echo (V7) is not supportable for this use!
fi
#
# NOTE: we don't export $echo et al -- they're just in the current shell

in_pathvar_p() {
	if [ $# -le 1 -o -z "${1}" ] ; then
		echo "Usage: in_pathvar_p pathvar directory [...]" >&2
		return 2
	fi
	eval "case :\$${1}: in *:${2}:*) return 0;; *) return 1;; esac"
}

# another way to do this without "test -d":
#
# PATH=`  IFS=: ; unset tpath
#	for pe in $candidates
#		do cd $pe &> /dev/null && tpath=${tpath+$tpath:}$pe ; done
#	echo "$tpath" `
#
#
dirappend ()
{
	if [ $# -le 1 -o -z "${1}" ] ; then
		echo "Usage: dirappend pathvar directory [...]" >&2
		return 2
	fi
	varname=${1}
	shift
	while [ $# -gt 0 ] ; do
		if [ -d "${1}" ]; then
			eval varvalue='${'${varname}'}'
			if in_pathvar_p ${varname} "${1}" ; then
				:
			else
				if [ -z "${varvalue}" ]; then
					eval ${varname}='"${1}"'
				else
					eval ${varname}='$'"${varname}"'":${1}"'
				fi
			fi
		fi
		shift
	done
	unset varname varvalue
}

dirprepend ()
{
	if [ $# -le 1 -o -z "${1}" ] ; then
		echo "Usage: dirprepend pathvar directory [...]" >&2
		return 2
	fi
	varname=${1}
	shift
	while [ $# -gt 0 ] ; do
		if [ -d "${1}" ]; then
			eval varvalue='${'${varname}'}'
			if in_pathvar_p $varname "${1}" ; then
				:
			else
				if [ -z "${varvalue}" ]; then
					eval ${varname}='"${1}"'
				else
					eval ${varname}='"${1}:"$'"${varname}"
				fi
			fi
		fi
		shift
	done
	unset varname varvalue
}

# XXX there's a slight flaw in this implementation -- it can't remove a
# double-empty trailing element (e.g. p=/path::; dirremove p '').  However two
# consecutive invocations will work to do this, or first do "removedups p".
#
# ToDo:  this should probably treat '' as '[.]*' and vice-versa so as to remove
# both implied and implicit current-directory entries at the same time, but
# that's tricky while still preserving the non-forking test using
# in_pathvar_p....
#
dirremove ()
{
	if [ $# -le 1 -o -z "${1}" ] ; then
		echo "Usage: dirremove pathvar directory [...]" >&2
		return 2
	fi
	varname=${1}
	shift
	while [ $# -gt 0 ] ; do
		if in_pathvar_p ${varname} "${1}" ; then
			eval ${varname}=`eval echo :'$'${varname}: | sed -e "s|:${1}:|:|g" -e "s|^:||" -e "s|:\$||"`
		fi
		shift
	done
	unset varname
}

# Another way...
#
pathvarrm ()
{
	if [ $# -le 1 -o -z "${1}" ] ; then
		echo "Usage: dirremove pathvar directory [...]" >&2
		return 2
	fi
	IFS=':'
	pathvar=${1}
	rmpath=${2}
	#
	# N.B.:  Instead of "set", ast-ksh/ksh93 and bash can use:
	#
	#	IFS=:
	#	for dir in ${!pathvar}; do
	#
	set -- `IFS=":"; eval echo '$'${pathvar}`
	for dir in "$@"; do
		if [ "${dir}" != "${opath}" ] ; then
			newpath=${newpath:+${newpath}:}${dir}
		fi
	done
	eval ${pathvar}="${newpath}"
}

removedups ()
{
	if [ $# -lt 1 -o -z "${1}" ] ; then
		echo "Usage: removedups pathvar" >&2
		return 2
	fi
	varname=${1}
	eval varvalue='${'${varname}'}'
	nvalue=`echo "${varvalue}" | awk -v RS=: -v ORS=: '
		BEGIN {
			A[""] = 0;
		}
		{
			# removing the newline is necessary in case the last
			# element is a duplicate
			#
			sub(/\n$/, "");
			if (! A[$0]) {
				A[$0]=1;
				printf("%s%s", ((NR == 1) ? "" : ORS ), $0);
			}
		}'
	`
	# XXX 'nbase' awk version 20121220 from Joyent packages core-dumps on macos
	rc=$?
	if [ ${rc} -ne 0 ]; then
		echo "removedups: awk failed: $rc" >&2
		unset varname varvalue nvalue rc
		return 1
	fi
	if [ -n "${nvalue}" ]; then
		eval ${varname}="${nvalue}"
	else
		echo "removedups: empty result!" >&2
		unset varname varvalue nvalue rc
		return 1
	fi
	unset varname varvalue nvalue rc
}

# ToDo:  consider rewriting the above so they accept '-F sepchar' and then the
# following can be eliminated?  (but what about the check for .../fonts.dir?
# maybe another option '-f file' to say the directory must contain a file named
# "file"?)

in_fppathvar_p() {
	if [ $# -le 1 -o -z "${1}" ] ; then
		echo "Usage: in_fppathvar_p fppathvar directory [...]" >&2
		return 2
	fi
	eval "case ,\$${1}, in *,${2},*) return 0;; *) return 1;; esac"
}

fpappend ()
{
	if [ $# -le 1 -o -z "${1}" ] ; then
		echo "Usage: fpappend fppathvar directory [...]" >&2
		return 2
	fi
	varname=${1}
	shift
	while [ $# -gt 0 ] ; do
		if [ -d "${1}" -a -r "${1}"/fonts.dir ]; then
			eval varvalue='${'${varname}'}'
			if in_fppathvar_p ${varname} "${1}" ; then
				:
			else
				if [ -z "${varvalue}" ]; then
					eval ${varname}='"${1}"'
				else
					eval ${varname}='$'"${varname}"'",${1}"'
				fi
			fi
		fi
		shift
	done
	unset varname varvalue
}

fpprepend ()
{
	if [ $# -le 1 -o -z "${1}" ] ; then
		echo "Usage: fpprepend fppathvar directory [...]" >&2
		return 2
	fi
	varname=${1}
	shift
	while [ $# -gt 0 ] ; do
		if [ -d "${1}" -a -r "${1}"/fonts.dir ]; then
			eval varvalue='${'${varname}'}'
			if in_fppathvar_p ${varname} "${1}" ; then
				:
			else
				if [ -z "${varvalue}" ]; then
					eval ${varname}='"${1}"'
				else
					eval ${varname}='"${1},"$'"${varname}"
				fi
			fi
		fi
		shift
	done
	unset varname varvalue
}

fpremove ()
{
	if [ $# -le 1 -o -z "${1}" ] ; then
		echo "Usage: fpremove fppathvar directory [...]" >&2
		return 2
	fi
	varname=${1}
	shift
	while [ $# -gt 0 ] ; do
		if in_fppathvar_p ${varname} "${1}" ; then
			eval ${varname}=`eval echo ,'$'${varname}, | sed -e "s|,${1},|,|g" -e "s|^,||" -e "s|,\$||"`
		fi
		shift
	done
	unset varname
}

pkgfirst ()
{
	dirremove PATH "$PKG/bin" "$PKG/sbin"
	dirprepend PATH "$PKG/bin"
}

pkglast ()
{
	dirremove PATH "$PKG/bin" "$PKG/sbin"
	dirappend PATH "$PKG/bin"
}

localfirst ()
{
	dirremove PATH "$LOCAL/bin" "$LOCAL/sbin"
	dirprepend PATH "$LOCAL/bin"
}

locallast ()
{
	dirremove PATH "$LOCAL/bin" "$LOCAL/sbin"
	dirappend PATH "$LOCAL/bin"
}

contribfirst ()
{
	dirremove PATH "$CONTRIB/bin" "$CONTRIB/sbin"
	dirprepend PATH "$CONTRIB/bin"
}

contriblast ()
{
	dirremove PATH "$CONTRIB/bin" "$CONTRIB/sbin"
	dirappend PATH "$CONTRIB/bin"
}

slashoptfirst ()
{
	dirremove PATH "$SLASHOPT/bin" "$SLASHOPT/sbin"
	dirprepend PATH "$SLASHOPT/bin"
}

slashoptlast ()
{
	dirremove PATH "$SLASHOPT/bin" "$SLASHOPT/sbin"
	dirappend PATH "$SLASHOPT/bin"
}

gnufirst ()
{
	dirremove PATH "$GNU/bin" "$GNU/sbin"
	dirprepend PATH "$GNU/bin" "$GNU/sbin"
}

gnulast ()
{
	dirremove PATH "$GNU/bin" "$GNU/sbin"
	dirappend PATH "$GNU/bin" "$GNU/sbin"
}

xpgfirst ()
{
	dirremove PATH /usr/xpg6/bin /usr/xpg4/bin ${PKG}/heirloom-xpg4/bin
	dirprepend PATH /usr/xpg6/bin /usr/xpg4/bin ${PKG}/heirloom-xpg4/bin
}

xpglast ()
{
	dirremove PATH /usr/xpg6/bin /usr/xpg4/bin ${PKG}/heirloom-xpg4/bin
	dirappend PATH /usr/xpg6/bin /usr/xpg4/bin ${PKG}/heirloom-xpg4/bin
}

# every truly POSIX-compliant shell implements the built-in
# command 'local', but then there's ksh (even #93!)
#
# AT&T Ksh is (still, as of ksh93u+) the only shell I know of which has
# functions, and which has a 'typset' command, but which does not have a 'local'
# command to declare function-scope variables, nor a "built-in" alias for it
# either.  Sigh.
#
# xxx strictly speaking this should probably always be a function that would
# treat any use of options as a usage error

defun_local="local () { :; }"

if is_attksh; then		# if type local >/dev/null 2>&1; then
	# Ksh93:
	#
	#	typeset vname[=value]
	#
	#	When invoked inside a function defined with the
	#	function name syntax, a new instance of the variable
	#	'vname' is created, and the variable's value and type
	#	are restored when the function completes.
	#
	# XXX Sadly this does not actually work for functions defined using the
	# "func() {body}", and that's the only portable way to define a
	# function!
	#
	# XXX so don't shadow globals in "fname(){}" functions!!!
	#
	# Note that in AT&T Ksh (and others?) aliases are resolved when a
	# function definition is first read in, so set this early!
	#
	# I used to like AT&T Ksh -- now I'm glad it's only an inspiration...
	#
	alias local='typeset'
else
	# for Bourne (heirloom) sh.
	if type local >/dev/null 2>&1; then
		:
	else
		# for Bourne (heirloom) sh, pbosh, etc.(?)
		#
		# This definition of "local" won't actually do anything useful,
		# but it also won't cause a syntax error either.
		#
		# xxx even though this is in an 'if' that souldn't be executed
		# by it, some versions of 'dash', aka "Debian Almquist shell"
		# (which started life as NetBSD sh) will barf and abort just
		# seeing this function definition for 'local' here!!!
		# (dash-0.5.5.1 is OK, dash-0.5.9.1 through 0.5.10.2 are STUPID)
		#
		# even worse it is almost impossible to detect dash
		# programatically.  However luckily we can hide the definition
		# in a variable value....
		#
		eval ${defun_local}
	fi
fi

unset defun_local

#
# Setup for ls(1) shortcuts.
#
LS_O=
LS_COLOUR=
HAVECOLORLS=false
# XXX perhaps we should just do the following in .profile:
# export CLICOLOR="defined"
if type colorls >/dev/null 2>&1; then
	LS_O=
	LS=`type colorls`
	LS=`expr "$LS" : '^[^/]*\(/[^ )]*\)'`
	HAVECOLORLS=true
	LS_COLOUR="-G"
fi
if type chflags >/dev/null 2>&1; then
	case `uname -s` in
	Darwin*)
		LS_O="O"
		HAVECOLORLS=true	# by coincidence....
		LS_COLOUR="-G"
		LS="/bin/ls"
		;;
	FreeBSD)
		LS_O="o"
		HAVECOLORLS=true	# by coincidence....
		LS_COLOUR="-G"
		LS="/bin/ls"
		;;
	*)
		LS_O="o"	# assume for the BSD best!
		;;
	esac
fi
if [ -z "${LS}" ]; then
	LS=`type ls`
	LS=`expr "$LS" : '^[^/]*\(/[^ )]*\)'`
	if ${LS} --version >/dev/null 2>&1; then
		# likely GNU ls....
		LS_O=""
		HAVECOLORLS=true
		LS_COLOUR="--color=auto"
	elif [ ${LS} = "/usr/bin/ls" ]; then
		# likely SysV-ish or Solaris?
		LS_O=""
		LS_COLOUR=""
	else
		# hmmm.... what could it be?
		LS_O=""
		LS_COLOUR=""
	fi
fi
if [ -n "$TERM" -a "X$TERM" != "Xdumb" ] && $HAVETPUT && $HAVECOLORLS; then
	# xxx colorls(1) is quite "dumb" -- it apparently just uses ANSI color
	# escape sequences directly without consulting $TERM
	if [ "`tput colors`" -gt 0 ]; then
		LS="${LS} ${LS_COLOUR}"
	fi
fi

if type mktable >/dev/null 2>&1; then
	MKTABLE="mktable"
else
	# a little ditty to throw away comment lines....
	# TODO: should this remove trailing comments too? (-e '/#.*$//')
	mktable ()
	{
		sed				\
			-e '/^[ 	]*#/d'	\
			-e '/^[ 	]*$/d'	\
		${1+"$@"}
	}
fi

# all machines without 'head' had a shell with functions... well, all that matter
#
if type head >/dev/null 2>&1; then
	: # have the real thing....
else
	head ()
	{
		N=10
		if [ $# -ge 1 ] ; then
			case "$1" in
			-[0-9]*)
				N=`expr x"$1" : '^x-\([0-9]*\)$'`
				shift
				;;
			-n)
				shift
				N=`expr x"$1" : '^x\([0-9]*\)$'`
				shift
				;;
			-*)
				echo "Usage: head [-N] [-n lines] [[file] ...]" 1>&2
				return 2
			esac
		fi
		sed ${N}q ${1+"$@"}

		unset N
	}
fi

: ${CENTRAL_USER:="woods"}
: ${CENTRAL_SERVER:="central.avoncote.ca"} # FQDN for outbound connections
: ${HOME_SERVER:="more"}
publishdotfiles ()
{
	if [ -z "${HOME}" ]; then
		echo "publishdotfiles: HOME is unset or empty!" 1>&2
		return 2
	fi
	case ${HOSTNAME} in
	${CENTRAL_SERVER%%.*}*)	# assume there is only one by this name!
		echo "publishdotfiles: not useful when run on server host!" 1>&2
		return 2
		;;
	${HOME_SERVER}*)
		( cd && ${SCCS:-"sccs"} info )
		( cd && git-sccsimport --move-date=2010/11/5T00:00:00 --move-offset=3 --expand-kw --maildomain=robohack.ca --git-dir="$HOME/work/home" --dirs SCCS && cd $HOME/work/home && git push --mirror )
		if [ $? -ne 0 ]; then
			echo "publishdotfiles:  check for errors above!"
			#
			# Quite possibly some aspect of some change that had
			# already been imported was accidentally changed causing
			# a fork in the change history.  One likely possibility
			# is some aspect of an SCCS file, e.g. a metadata value
			# which appears in the expanded "@(#)" header, was
			# modified, e.g. the module type.
			#
			# In this case there are two choices -- (1) undo the
			# change; or (2) rewrite the git history.
			#
			# For this particular repository the second option is
			# probably OK.  Do the following:
			#
			#   git reset --hard $(git log HEAD^..HEAD | awk '$1 == "commit" {print $2}')
			#   git push --force --mirror
			#
		fi
		rsync -v -lptHS --progress --delete-after --stats --files-from=$HOME/dotfiles.list $HOME ${CENTRAL_USER}@${CENTRAL_SERVER}:.
		#
		archivedotfiles
		;;
	*)
		echo "publishdotfiles: not useful when run on client host!" 1>&2
		return 2
		;;
	esac
}

archivedotfiles ()
{
	# XXX somehow this should be combined with vnewrel, or should call
	# vnewrel (sometimes)??
	#
	# XXX also put them on the FTP server?  (only when vnewrel?)
	#
	# (note I had never put these in /work/release.d, so no need to now)
	#
	(cd; pax -wzf ${HOME}/dotfiles.tar.gz < ${HOME}/dotfiles.list)
	ssh ${CENTRAL_USER}@${CENTRAL_SERVER} rm -f dotfiles.list
	scp ${HOME}/dotfiles.list ${HOME}/dotfiles.tar.gz ${CENTRAL_USER}@${CENTRAL_SERVER}:.
	#
	# publish via HTTP too -- xxx this is a bit wasteful, but simplest...
	(cd $HOME/public_html; ./publish)
}

pushdotfiles ()
{
	_e_opt=""
	_user=${LOGNAME}
	_copy=false
	_transport=${RSYNC_RSH:-"scp"}
	_USAGE="pushdotfiles: Usage: pushdotfiles [-c] [-e TRANSPORT] [-u RUSER] hostname"
	OPTIND="1"
	while getopts "ce:u:" OPTCH
	do
		case ${OPTCH} in
		c)
			_copy=true
			;;
		e)
			_e_opt="-e ${OPTARG}"
			case ${OPTARG} in
			r*)
				_transport=rcp
				;;
			s*)
				_transport=scp
				;;
			*)
				echo "pushdotfiles: ${OPTARG}: unknown transport" >&2
				return 2
			esac
			;;
		u)
			_user="${OPTARG}"
			;;
		*)
			echo "$_USAGE" >&2
			return 2
			;;
		esac
	done
	shift `expr $OPTIND - 1`

	if [ $# -ne 1 ]; then
		echo "$_USAGE" >&2
		return 2
	fi
	if $_copy; then
		if [ $_transport = "rcp" ]; then
			echo "pushdotfiles: the rcp transport cannot create subdirectories!" >&2
			return 2
		fi
		cd $HOME && \
		$_transport -r `cat ${HOME}/dotfiles.list` ${1}:
	else
		rsync ${_e_opt} -v -lptHS --progress --delete-after --stats --files-from=${HOME}/dotfiles.list ${HOME} ${_user}@${1}:.
	fi
	unset _copy _e_opt _user _USAGE OPTCH
}

syncdotfiles ()
{
	# In theory this could have command-line options to set/override
	# $CENTRAL_*, but that can also be done simply as variable assignments
	if [ -z "${HOME}" ]; then
		echo "syncdotfiles: HOME is unset or empty!" 1>&2
		return 2
	fi
	case ${HOSTNAME} in
	${CENTRAL_SERVER%%.*}*)	# assume there is only one by this name!
		echo "syncdotfiles: not useful when run on server host!" 1>&2
		return 2
		;;
	${HOME_SERVER}*)
		# xxx should check if $HOME is /home/more/$USER?
		echo "syncdotfiles: not useful when run on edit host!" 1>&2
		return 2
		;;
	esac
	rsync -v -lptHS --progress --delete-after --stats --files-from=:dotfiles.list ${CENTRAL_USER}@${CENTRAL_SERVER}:. $HOME
	if [ -r $HOME/.xinitrc -a ! -x $HOME/.xinitrc ] ; then
		chmod +x $HOME/.xinitrc
	fi
	if ${HAVEEMACS}; then
		if [ $HOME/.emacs.el -nt $HOME/.emacs.elc ]; then
			( cd $HOME && ${MY_EMACS} -batch -q -no-site-file -f batch-byte-compile .emacs.el )
		fi
	fi
}

set_LOCAL_et_al ()
{
	if [ -z "${LOCAL}" ] ; then
		# NOTE:  ${LOCAL} must not contain multiple words!
		if [ -d /local -a ! -L /local ] ; then
			LOCAL="/local"
		elif [ -d /usr/local -a ! -L /usr/local ] ; then
			LOCAL="/usr/local"
		else
			LOCAL="/NO-local-FOUND"
		fi
	fi
	export LOCAL

	if [ -z "${CONTRIB}" ] ; then
		# NOTE:  ${CONTRIB} must not contain multiple words!
		if [ -d /contrib -a ! -L /contrib ] ; then
			CONTRIB="/contrib"
		elif [ -d /usr/contrib -a ! -L /usr/contrib ] ; then
			CONTRIB="/usr/contrib"
		else
			CONTRIB="/NO-contrib-FOUND"
		fi
	fi
	export CONTRIB

	if [ -z "${PKG}" ] ; then
		# NOTE:  ${PKG} must not contain multiple words!
		# XXX some OSX has an un-related /pkg so test /{usr,opt}/pkg first!
		if [ -d /usr/pkg -a ! -L /usr/pkg ] ; then
			PKG="/usr/pkg"
		elif [ -d /opt/pkg -a ! -L /opt/pkg ] ; then
			PKG="/opt/pkg"
		elif [ -d /pkg -a ! -L /pkg ] ; then
			PKG="/pkg"
		else
			PKG="/NO-pkg-FOUND"
		fi
	fi
	export PKG

	if [ -z "${SLASHOPT}" ] ; then
		# NOTE:  ${SLASHOPT} must not contain multiple words!
		if [ -d /opt ] ; then
			SLASHOPT="/opt"
		elif [ -d /usr/opt -a ! -L /usr/opt ] ; then
			SLASHOPT="/usr/opt"
		else
			SLASHOPT="/NO-opt-FOUND"
		fi
	fi
	export SLASHOPT

	if [ -z "${GNU}" ] ; then
		# NOTE:  ${GNU} must not contain multiple words!
		if [ -d /local/gnu -a ! -L /local/gnu -a -d /local/gnu/bin ] ; then
			GNU="/local/gnu"
		elif [ -d /usr/gnu -a -d /usr/gnu/bin ] ; then
			GNU="/usr/gnu"
		elif [ -d /usr/local/gnu -a -d /usr/local/gnu/bin ] ; then
			GNU="/usr/local/gnu"
		elif [ -d /usr/pkg/gnu -a -d /usr/pkg/gnu/bin ] ; then
			GNU="/usr/pkg/gnu"
		elif [ -d /opt/pkg/gnu -a -d /opt/pkg/gnu/bin ] ; then
			GNU="/opt/pkg/gnu"
		elif [ -d /opt/gnu -a -d /opt/gnu/bin ] ; then
			GNU="/opt/gnu"
		else
			GNU="/NO-gnu-FOUND"
		fi
	fi
	export GNU

	if [ -z "${PROJECT}" ] ; then
		PROJECT="SCCS"
	fi
	export PROJECT
}

if [ -z "${WORKPATH}" ] ; then
	WORKPATH=${HOME}/work.d:${HOME}/work
fi
dirappend WORKPATH /work/${LOGNAME} ${LOCAL}/work.d/${LOGNAME}
export WORKPATH

if $ISSUN; then
	NETBSDSRCDIR=/work/src
	BSDSRCDIR=/work/src
	X11SRCDIR=/work/xsrc
	PKGSRCDIR=/work/pkgsrc
	PORTSSRCDIR=/work/ports
elif [ `uname -s` = "Darwin" ]; then
	#
	# Modern macOS won't let root create symlinks in / or /usr....
	#
	NETBSDSRCDIR=/Volumes/work/src
	BSDSRCDIR=/Volumes/work/src
	X11SRCDIR=/Volumes/work/xsrc
	PKGSRCDIR=/Volumes/work/pkgsrc
	PORTSSRCDIR=/Volumes/work/ports
else
	NETBSDSRCDIR=/usr/src
	BSDSRCDIR=/usr/src
	X11SRCDIR=/usr/xsrc
	PKGSRCDIR=/usr/pkgsrc
	PORTSSRCDIR=/usr/ports
fi

# CDPATH isn't supported in all shells, but it won't hurt....
#
# make sure these directories are fixed in even if they are not
# present at login time.
#
if [ -n "${CDPATH}" ]; then
	OCDPATH=${CDPATH}; export OCDPATH
fi
CDPATH=:${HOME}:${WORKPATH}:${HOME}/src:${HOME}/src/lib:${NETBSDSRCDIR}:${BSDSRCDIR}:${X11SRCDIR}:${PKGSRCDIR}:${PORTSSRCDIR}

export CDPATH

if [ -z "${CVSROOT}" ] ; then
	CVSROOT=${LOCAL}/src-CVS ; export CVSROOT
fi

# on older systems GNU Diff is preferred for things that use $DIFF,
# but sometimes it's in ${LOCAL}/bin as just "diff"
#
if [ -x ${LOCAL}/bin/diff ] ; then
	DIFF=${LOCAL}/bin/diff
elif type gdiff >/dev/null 2>&1; then
	# XXX this isn't always best any more!
	DIFF="gdiff"
else
	# xxx this is probably a no-op...
	DIFF="diff"
fi
export DIFF

if type make >/dev/null 2>&1; then
	if make -v >/dev/null 2>&1; then
		# oops, this system thinks GNU Make is a real Make!
		# Assume there is or will be a "bmake", aka BSD Make
		BMAKE="bmake"
	else
		# Assume for the best...
		BMAKE="make"
	fi
else
	# Hope for the best, eventually...
	BMAKE="make"
fi
export BMAKE

# n.b.:  see also the corresponding elisp functions
#
dfgit2magit ()
{
	if [ -d $HOME/.git ]; then
		echo "dfgit2magit: already in 'magit' mode?" >&2
		return 2
	fi
	if [ ! -d $HOME/.dotfiles-git ]; then
		echo "dfgit2magit: \~/.dotfiles-git missing?" >&2
		return 2
	fi
	mv $HOME/.dotfiles-git $HOME/.git
}

# n.b.:  see also the corresponding elisp functions
#
magit2dfgit ()
{
	if [ -d $HOME/.dotfiles-git ]; then
		echo "magit2dfgit: already in 'dfgit' mode!" >&2
		return 2
	fi
	if [ ! -d $HOME/.git ]; then
		echo "magit2dfgit: \~/.git missing?" >&2
		return 2
	fi
	mv $HOME/.git $HOME/.dotfiles-git
}

dfgit ()
{
	if [ -d $HOME/.git -o ! -d $HOME/.dotfiles-git ]; then
		echo "dfgit: in 'magit' mode!  Run magit2dfgit" >&2
		return 2
	fi
	git --git-dir=$HOME/.dotfiles-git/ ${1+"${@}"}
}

lnotes ()
{
	if [ -d $HOME/notes ] ; then
	(
		# in a subshell
		\cd $HOME/notes
		if [ `ls|wc -w` != 0 ] ; then
			echo 'You have notes on: '
			${LS} -dC *[!~]
		fi
	)
	fi
}

#
#	more functions
#

adjlinks ()
{
	# XXX are separate "from" and "to" options better, or should they be
	# just one sed expression, and should it/they be options or args?
	#
	# XXX could/should check if new target exists?

	_USAGE="Usage: adjlinks -f fromRE -t toSTR symlink ..."
	OPTIND="1"
	while getopts "f:t:" OPTCH
	do
		case ${OPTCH} in
		f)
			_from=${OPTARG}
			;;
		t)
			_to=${OPTARG}
			;;
		*)
			echo "$_USAGE" >&2
			return 2
			;;
		esac
	done
	shift `expr $OPTIND - 1`

	if [ -z "${_from}" -o -z "${_to}" -o $# -lt 1 -o -z "$1" ]; then
		echo "$_USAGE" >&2
		return 2
	fi

	for _lnk
	do
		_otarg=`readlink "${_lnk}"`
		if [ $? -eq 0 ]; then
			_ntarg=`echo "${_otarg}" | sed "s|${_from}|${_to}|"`
			if [ "${_otarg}" != "${_ntarg}" ]; then
				rm -f "${_lnk}"
				ln -s "${_ntarg}" "${_lnk}" && echo adjusted: "${_lnk}" '->' "${_otarg}" to: '->' "${_ntarg}"
			fi
		fi
	done
	unset _USAGE _from _to _lnk _otarg _ntarg OPTCH
}

checkptrs ()
{
	if [ $# -ne 1 ]; then
		echo "Usage: checkptrs [ 192.168.1.0 | 1.168.192.in-addr.arpa ]" >&2
		return 2
	fi
	_i=0
	_in_addr_arpa=$1

	case ${_in_addr_arpa} in
	*.in-addr.arpa)
		:
		;;
	*)
		_in_addr_arpa=`echo ${_in_addr_arpa} | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)/\3.\2.\1/'`".in-addr.arpa"
	esac
	echo "checkptrs: checking for all PTRs in: ${_in_addr_arpa}"
	while [ $_i -lt 255 ]; do
		host -a ${_i}.${_in_addr_arpa} 2>/dev/null || true;
		_i=`expr ${_i} + 1`
	done
	unset _i _in_addr_arpa
}

cdpkgwrksrc ()
{
	# XXX don't do anything if not directly in a pacakge dir
	#
	# note:  this can use '${BMAKE} -v WRKSRC' once bmake-20200524 or newer
	# is purvasive....
	#
	cd `${BMAKE} show-var VARNAME=WRKSRC`
	pwd
}

# this name is chosen so as to complement cdpkgwrksrc to facilitate easier
# completion after typing the first three letters
#
cdwrkpkg ()
{
	# XXX don't do anything if not directly in a pacakge dir
	cd `${BMAKE} show-var VARNAME=WRKDIR`
	pwd
}

cvsupdateroot ()
{
	_newroot=$1

	find . -name Root -print | fgrep CVS/Root | while read _rootfile ; do
		echo $_newroot > $_rootfile
	done
	unset _newroot _rootfile
}

# XXX what good is this again?
#
difforig ()
{
	_DIFFOPTS=""
	if [ $# -le 2 ]; then
		echo "Usage: difforig [-DIFFOPTS] file" >&2
		return 2
	fi
	case "$1" in
	-*)
		_DIFFOPTS=$1
		shift
		;;
	esac
	diff $_DIFFOPTS $1.orig $1
	unset _DIFFOPTS
}

filerot ()
{
	:
	# xxx move file to file-, after file- to file-- and so on...
}

get_domainname ()
{
	if [ -r /etc/resolv.conf ] && fgrep domain /etc/resolv.conf >/dev/null 2>&1; then
		#
		# here we use domain, not "search", on purpose so that
		# we will only set DOMAINNAME if that's been done
		# explicitly in resolv.conf -- normally dhclient and
		# such will set "search" from the network DHCP server
		#
		# xxx except of course on MacOS X, aka OSX, aka macOS, sigh...
		#
		sed -n '/^[;#]/d;s/domain[ 	]*/./p' /etc/resolv.conf
	elif type domainname >/dev/null 2>&1; then
		#
		# for laggards like me who use this for DNS too
		#
		_D=domainname
		if expr "${_D}" : '^\.' >/dev/null 2>&1 ; then
			echo ${_D}
		else
			echo .${_D}
		fi
		unset _D
	elif expr "${HOSTNAME}" : '[^\.]*\.' >/dev/null 2>&1; then
		echo "."`expr "${HOSTNAME}" : '[^\.]*\.\(.*\)$'`
	else
		# these cases for machines without domainname,
		# and a short hostname....
		#
		case "${UUNAME}" in
		weirdo )
			echo ".weird.com"
			;;
		* )
			echo ".UUCP"
			;;
		esac
	fi
}

get_macos_sdk_path ()
{
	# n.b.:  to see all installed SDKs:
	#
	#	xcodebuild -showsdks
	#
	xcrun -sdk macosx --show-sdk-path
}
SKPREFIX=""
if [ `uname -s` = "Darwin" ]; then
	#
	# this is actually the same as ${SDKROOT} as set by xcrun(1), but for
	# now a different name in the login shell environment is probably
	# apropos...
	#
	SDKPREFIX=`get_macos_sdk_path`
fi
export SDKPREFIX		# xxx hmmm.... should it be exported?

# to deal with shells that may not expand '~' in pathnames
#
# Leverages possible expansion first thus avoiding any obvious fork(s) and
# external command exec(s)
#
get_user_home ()
{
	if [ $# -ne 1 ]; then
		echo "Usage: get_user_home username" >&2
		return 2
	fi
	eval _uhdir=~$1
	case "${_uhdir}" in
	/*)
		echo $_uhdir
		unset _uhdir
		return 0
		;;
	esac
	unset _uhdir
	if type getent >/dev/null 2>&1; then
		getent passwd $1 | awk -F: '{print $6}'
	else
		awk -F: '$1 == "'$1'" {print $6}' < /etc/passwd
	fi
}

# this is a bit like the GNU (err, vim) "xxd -p", but far more portable
#
hexencode ()
{
	hexdump -v -e '1/1 "%02x"'
}

# xxx hmmm... this works!  (assuming we have printf(1), of course)
#
hexdecode ()
{
	sed 's/\([0-9A-Fa-f]\{2\}\)/\\\\\\x\1/g' | xargs printf
}

# xxx this needs an option to specify which column or position the address is in
#
ipaddrsort ()
{
	sed 's/\./ /g' ${1} |
	  sort -b -n -k 1 \
		  -n -k 2 \
		  -n -k 3 \
		  -n -k 4 |
	  sed -E -e 's/([0-9]) /\1./' \
		 -e 's/([0-9]) /\1./' \
		 -e 's/([0-9]) /\1./'
}

imgsize ()
{
	# note modern file(1) can print size too, but not consistently for
	# differnt image types....
	#
	if type exiv2 >/dev/null 2>&1; then
		exiv2 ${1+"$@"} 2>/dev/null | awk '$1 == "Image" && $2 == "size" {print $4 " " $5 " " $6;}'
	else
		# xxx so this only works for JPEGs...
		#
		file ${1+"$@"} | awk '{print $1 " " $(NF-2)}'
	fi
}

kall ()
{
	_SIGOPT=""

	case "$1" in
	-*)
		_SIGOPT=$1
		shift;
		;;
	esac
	kill $_SIGOPT `ps -x | awk '$5 == "'$1'" {print $1}'`
	unset _SIGOPT
}

if type killall >/dev/null 2>&1; then
	: already have a good killall?
else
	killall ()
	{
		if [ $# -eq 1 ]; then
			_signal="-TERM"
			_cmd=$1
		elif [ $# -eq 2 ]; then
			_signal=$1
			_cmd=$2
		fi
		kill $_signal `ps -ax -o pid,ucomm | awk '$2 == "'$_cmd'" { print $1}'`
		unset _signal _cmd
	}
fi

krcmd ()
{
	kill -9 `ps -ax -o uid,pid,ppid,ucomm | awk '$1 == '${id}' && $3 == 1 && $4 == "rcmd" {print $2}'`
}

mailclients ()
{
	awk '$4 == "remote" && $5 == "connection" && $6 == "from" {
		sub(/\[.*$/, "", $7);
		print $7;
	}' ${1+"$@"}
}

mailsizes ()
{
	awk '$5 == "Received" {
		for (fn = 6; fn <= NF; fn++) {
			if (substr($fn, 1, 5) == "SIZE:") {
				size = substr($fn, 6) + 0;
				break;
			}
		}
		print size;
	}' ${1+"$@"}
}

repfirst ()
{
	# replace only the first occurance of $1 found in the input with $2
	#
	# from https://stackoverflow.com/a/33416489

	sed -e "1 s/${1}/${2}/; t" -e "1,// s//${2}/"

	# GNU Sed supports "0,/RE/" as an address range (such that if /RE/
	# matches at the very first line of input then it will already be at the
	# end of its range, whereas "1,/RE/" would still be at the beginning of
	# its range) so GNU Sed can do this with just one expression:
	#
	#	gsed -d "0,/$1/s//$2/"
	#
	# AWK equivalent:
	#
	#	awk "/$1/ && !done { sub(/$1/, \"$2\"); done=1; }; 1;"
}

reverse_word_order ()
{
	_result=""
	for _word in $@; do
		_result="$_word $_result"
	done
	echo "$_result"
	unset _result _word
}

sedjoinnext ()
{
	# pattern that starts the lines to be appended to their previous lines
	# (note a blank is inserted in place of the newline)
	#
	_start=$1

	sed -e ':a' -e '$!N;s/\n'"${_start}"'/ \1/;ta' -e 'P;D'
	unset _start
}

# Display the opening doc comment in a script file.
#
shelp () {
        _binfile=`which "$0"`

        _hdr=`dd if="$_binfile" count=2 bs=1`
        if [ "$_hdr" = "#!" ]; then
	        sed -rn 's/^### ?//;T;p' "$_binfile"
        fi
	unset _binfile _hdr
}

show_make_var ()
{
	# a more portable version of "make -V \${1}'
	#
	echo "show-var-${1}:;@echo \${$1}" | ${MAKE:-"make"} -f - -f Makefile "show-var-${1}"
}

show_cc_predef ()
{
	${CC:-"cc"} -E -dM -x c /dev/null | sort
}

show_cc_optim ()
{
	# to show optimizer options (and include path, and build info, etc.):
	#
	#OPTIM="-O4"
	#OPTIM="-O3"
	#OPTIM="-O2"
	#OPTIM="-O1"
	#OPTIM="-O0"
	#
	${CC:-"cc"} -v ${OPTIM:-"-O4"} -S -fverbose-asm -o - -x c /dev/null
}

#sedjoinafter ()
#{
#	# pattern that ends the lines to be joined with to their previous lines
#	#
#	end=$1
#
#	sed -e :a -e '/\\$/N; s/\\\n//; ta'
#}

signm ()
{
	grep "^#define[ 	]*SIG.*[ 	]*${1}[ 	]" ${SDKPREFIX}/usr/include/sys/signal.h
}

signo ()
{
	grep -i "^#define[ 	]*.*${1}[ 	]*[0-9]" ${SDKPREFIX}/usr/include/sys/signal.h
}

snmpmiblist ()
{
	cd $1; echo `awk '{print $1}' .index` | sed 's/ /:/g'
}

if [ -f /usr/adm/lastlog.ut -a -x /usr/lib/acct/fwtmp ] ; then
	lastlog ()
	{
		YearGrep="grep `date +%Y`"
		if [ $# -eq 1 -a "$1" = "-a" ] ; then
			YearGrep="grep -v 1969"
		elif [ $# -ne 0 ] ; then
			echo 'Usage: lastlog [-a]' >&2
		fi
		/usr/lib/acct/fwtmp < /usr/adm/lastlog.ut | $YearGrep |
			awk '{printf("%-8s %-12s %s\n", $1, $3, substr($0, 56))}'
		unset YearGrep
	}
fi

# these are mostly here (instead of in ~/.profile) for get_newterm()...
#
# N.B.:  note the use of $_ttytype, for $TERMTESTCMD, shared with get_newterm()
# below!
#
HAVETPUT=false
if type tput >/dev/null 2>&1; then
	HAVETPUT=true
	# WARNING: this may only work with a SysV compatible tput.
	# N.B.:  bit-bucket all output -- it is run in ~/.profile for real.
	TERMTESTCMD='tput -T"$_ttytype" init >/dev/null 2>&1'
elif type tset >/dev/null 2>&1; then
	# WARNING:  some tset(1)'s, esp. ULTRIX, fail if stderr is not
	# a tty.  Worse, most will query for a new terminal type if it
	# is unknown!  Note also that '-q' isn't accepted by even
	# recent BSD versions, but '-' is still accepted by the
	# ncurses variant.
	#
	TERMTESTCMD='tset - -I -Q "$_ttytype" </dev/null >/dev/null'
else
	TERMTESTCMD='true'
fi

# this is a function so it can be used interactively after login....
#
# NOTE:  this uses $echo et al, as well as $TERMTESTCMD, none which are
# exported, but they are set by this file, so should be available for all
# interactive shells....
#
# XXX N.B.:  This may not work if functions cannot set global/environment vars,
# though that is only true on ancient non-POSIX compatible shells
#
get_newterm ()
{
	_newttytype=
	_ttytype=$TERM
	TERM=

	while [ "X$TERM" != "X$_ttytype" ] ; do
		$echo $n "Please enter your terminal type [$_ttytype]: $c"
		read _newttytype
		if [ -n "$_newttytype" ] ; then
			_ttytype=$_newttytype
		fi
		if [ "$_ttytype" = "dumb" ] ; then
			# n.b.:  we must guarantee a way out of this loop!
			#
			# (that's because tput(1) hates dumb terminals, i.e. it
			# exits non-zero if the terminal doesn't support the
			# "init" attribute)
			TERM="dumb"
			break
		fi
		if eval $TERMTESTCMD ; then
			TERM=$_ttytype
		else
			echo "Sorry, I don't know that terminal type."
			echo "Use 'dumb' if you are stuck."
		fi
	done
	unset _newttytype _ttytype
	export TERM
}

if [ -n "$DISPLAY" ]; then
	onx11server ()
	{
		_RDISPLAY=${REMOTE_DISPLAY:-${DISPLAY}}
		_REMSHELL=${RSH:-rsh}
		# note: $argv0 will have been set by .xinitrc, but....
		_USAGE="onx11server: Usage: onx11server [-n[S]|-[f]S] [-D REMOTE_DISPLAY] X11SERVERNAME 'command string'"
		_nullopt=""
		OPTIND="1"
		while getopts "fnD:S" OPTCH
		do
			case ${OPTCH} in
			n|f)
				# for ssh '-f' puts itself into the
				# background and implies '-n'
				_nullopt="-${OPTCH}"
				;;
			D)
				_RDISPLAY=${OPTARG}
				;;
			S)
				_REMSHELL=${SSH:-ssh}
				;;
			*)
				echo "$_USAGE" >&2
				return 2
				;;
			esac
		done
		shift `expr $OPTIND - 1`

		if [ $# -ne 2 -o -z "$1" ]; then
			echo "$_USAGE" >&2
			return 2
		fi

		_X11server=$1

		echo "onx11server: starting $_REMSHELL $_nullopt $_X11server '. ./.profile; DISPLAY=${_RDISPLAY}; export DISPLAY; exec $2'"
		# note:  do not run this in the background -- let the
		# caller do that (unfortunately we must have a shell
		# waiting for the rsh/ssh to keep the connection open
		# so that the remote process will continue running.
		$_REMSHELL $_nullopt $_X11server ". ./.profile; DISPLAY=${_RDISPLAY}; export DISPLAY; exec $2"

		unset _RDISPLAY _REMSHELL _USAGE _nullopt _X11server OPTCH
	}
	lxterm ()
	{
		# XXX for a true "login" window we should use "-e login -pf ${USER:-${LOGNAME}}"
		# alternatively:  unset LC_ALL; eval export `locale` ; unset LC_ALL
		LANG=C LC_ALL=C xterm -ziconbeep 1 -fa '-*-*-medium-r-normal-*-*-*-*-*-m-0-iso10646-1' -fs 9 -fbx -cn -rw -sb -si -sk -sl 2048 -ls -T $HOSTNAME ${1+"$@"} &
	}
	luxterm ()
	{
		# XXX for a true "login" window we should use "-e login -pf ${USER:-${LOGNAME}}"
		uxterm -ziconbeep 1 -fa '-*-*-medium-r-normal-*-*-*-*-*-m-0-iso10646-1' -fs 9 -fbx -cn -rw -sb -si -sk -sl 2048 -ls -T $HOSTNAME ${1+"$@"} &
	}
	rxauth ()
	{
		_RDISP=${REMOTE_DISPLAY:-${DISPLAY}}

		xauth nextract - ${_RDISP} | onx11server ${1+"$@"} 'xauth nmerge -'
		unset _RDISP
	}
	rxterm ()
	{
		_rhost=$1
		shift
		# alternatively:  unset LC_ALL; eval export `locale` ; unset LC_ALL
		onx11server ${1+"$@"} "LANG=C LC_ALL=C xterm -ziconbeep 1 -fa '-*-*-medium-r-normal-*-*-*-*-*-m-0-iso10646-1' -fs 9 -cn -rw -sb -si -sk -sl 2048 -ls -T rsh:$_rhost $*" &
	}
	ruxterm ()
	{
		shift
		onx11server ${1+"$@"} "uxterm -ziconbeep 1 -fa '-*-*-medium-r-normal-*-*-*-*-*-m-0-iso10646-1' -fs 9 -cn -rw -sb -si -sk -sl 2048 -ls -T rsh:$_rhost $*" &
	}
fi

do_first_time ()
{
	# TODO:  do something with msgs(1) if needed....
	# TODO:  should use $HAVEFORTUNE and $FORTUNE
	if [ -x /usr/games/fortune ] ; then
		echo ""
		/usr/games/fortune
	elif [ -x ${LOCAL}/games/fortune ] ; then
		echo ""
		${LOCAL}/games/fortune
	fi
	if [ -r calendar -o -r diary -o -r .month ] ; then
		echo ""
		echo "Today's Events:"
		if ${HAVEMONTH} && [ -r .month ] ; then
			month -B
			#		monthd -i5
		fi
		if ${HAVECALENDAR} ; then
			if [ -r calendar ] ; then
				calendar -l 2 -w 4
			elif [ -r diary ] ; then
				#
				# uses cpp, which gets confused with some
				# comments....  and unfortunately won't accept
				# '-f -', nor will it read from /dev/stdin or
				# /fdesc/stdin...  grrr....
				#
				calendar -l 2 -w 4 -f diary 2>/dev/null
			fi
		fi
	fi
	if [ -r ${HOME}/.trninit${TERM} ] ; then
		TRNINIT=${HOME}/.trninit${TERM} ; export TRNINIT
	fi
	lnotes
}

ISATTY="true"
# xxx && [ "X$argv0" != "X.xsession" -a "X$argv0" != "X.xinitrc" ] 
TTY=`tty` || ISATTY="false"	# "not a tty" if not...
if ${ISATTY}; then
	TTYN=`basename $TTY`
else
	TTYN="not-tty"
fi

if type ismpx >/dev/null 2>&1; then
	: might just be running layers
else
	# otherwise it's just not possible....
	ismpx ()
	{
		if [ X$1 != X"-s" ]; then
			echo "no"
		fi
		false
	}
fi

if ismpx -s || [ "$TERM" = "dmd-myx" ] ; then
	if [ "${LEV:-0}" -eq 0 ] ; then
		# in xterms, we are (normally, supposed to be) a login
		# shell, but not in layers
		do_first_time
	fi
	if [ -z "${D_PS1}" ]; then
		PS1="${PS1}${UUNAME}"
	fi
	MYXCLR_L="`myxban -l`"
	MYXCLR_C="`myxban -c`"
	MYXCLR_R="`myxban -r`"
	MYXCLR=${MYXCLR_L}${MYXCLR_C}${MYXCLR_R}
	MYXBAN_L='${BANNER_PWD}'

	clearban ()
	{
		$echo $n "${MYXCLR}$c"
		WBANNER="${OWBANNER}"
		setban
	}

	setban ()
	{
		if [ $# -ge 1 ]; then
			OWBANNER=${WBANNER}
			# no trailing space -- usually just used to
			# set alternate shell name
			WBANNER="$@"
		fi
		if [ -z "$BANNER_PWD" ]; then
			BANNER_PWD=`pwd | sed -e "s;^$HOME;~;" -e 's;^.*/work.d/;work.d/;' -e 's;.*/home.*/\([^/][^/]*\)$;\~\1;'`
		fi
		$echo $n "${MYXCLR}$c"
		eval myxban -l "\"$MYXBAN_L\""
		myxban -c "${WBANNER:-`basename ${SHELL}`}"
		eval myxban -r "\"$MYXBAN_R\""
		unset BANNER_PWD
	}

	psm ()
	{
		ps -ft `tty | sed 's|/dev/xt|xt/|'`
	}

fi
# else
case "$TERM" in
*xterm*)
	if [ -z "${D_PS1}" ]; then
		PS1="${PS1}${UUNAME}"
	fi

	clearban ()
	{
		WBANNER="${OWBANNER}"
		setban
	}
	# for debugging, i.e. to show clearban is indeed being called...
	#
	#if type typeset >/dev/null 2>&1; then
	#	typeset -ft clearban
	#fi

	setban ()
	{
		if [ $# -ge 1 ]; then
			OWBANNER=${WBANNER}
			# no trailing space -- usually just used to
			# set alternate shell name
			WBANNER=${1+"${@}"}
		fi
		if [ -z "$BANNER_PWD" ]; then
			# only if needed (it's expensive), would be done by 'cd'
			# if possible
			#
			# XXX ToDo:  should extract the version in .shpwd as a
			# separate function
			BANNER_PWD=`pwd | sed -e "s;^$HOME;~;" -e 's;^.*/work.d/;work.d/;' -e 's;.*/home.*/\([^/][^/]*\)$;\~\1;'`
		fi
		if is_attksh; then
			# XXX ksh93 massively messes up parsing backticks in a
			# variable expansion -- it never finds the second one!!!
			if [ "$user" = "$LOGNAME" ]; then
				TBANNER="${WBANNER:-$(basename ${SHELL})}://$UUNAME/$BANNER_PWD | $user[$LEV]:$TTYN"
			else
				TBANNER="${WBANNER:-$(basename ${SHELL})}://$UUNAME/$BANNER_PWD | $user:$group($LOGNAME)[$LEV]:$TTYN"
			fi
		else
			if [ "$user" = "$LOGNAME" ]; then
				TBANNER="${WBANNER:-`basename ${SHELL}`}://$UUNAME/$BANNER_PWD | $user[$LEV]:$TTYN"
			else
				TBANNER="${WBANNER:-`basename ${SHELL}`}://$UUNAME/$BANNER_PWD | $user:$group($LOGNAME)[$LEV]:$TTYN"
			fi
		fi
		if type printf >/dev/null 2>&1; then
			printf "\033]0;%s\007" "${TBANNER}"
		else
			$echo $n "\033]0;${TBANNER}\007$c"
		fi

		unset BANNER_PWD
	}
	;;
*)
	# assume there's only a plain terminal with no banner line...
	#
	if [ -z "${D_PS1}" ]; then
		if [ "$user" != "$LOGNAME" ] ; then
			PS1="${PS1}$TTYN:$user($LOGNAME)@$UUNAME)"
		else
			PS1="${PS1}$TTYN:$LOGNAME@$UUNAME"
		fi
	fi
	;;
esac

if type setban >/dev/null 2>&1; then

	setban

	# XXX most versions of SysV sh always run builtins before functions
	# though Heirloom Sh does not.
	#
	# xxx this may be redefined immediately if ~/.shpwd is readable, or
	# later for certain shells if their custom ~/.${SHELL}pwd is readable
	#
	cd ()
	{
		# note this has to support various ksh without chdir and/or
		# weird "builtin" as $ENV won't be sourced until after .profile
		# is finished, and we try "cd" at the end of this file...
		#
		if type chdir >/dev/null 2>&1; then
			chdir ${1+"$@"}
		elif type command >/dev/null 2>&1; then
			command cd ${1+"$@"}
		else
			builtin cd ${1+"$@"}
		fi
		PWD=`pwd`
		BANNER_PWD=${PWD}
		setban
	}

	if [ -r $HOME/.shpwd ] ; then
		. $HOME/.shpwd
	fi

	#
	# XXX ToDo:  re-factor into a function which defines functions....
	#
	# I.e. write the function definition into a variable value, then eval
	# the variable to define the function.  (See experiments/tfunc.sh)
	#

	# xxx we don't try to preserve any original traps for 1 2 3 15....

	if [ "$VISUAL" = "emacsclient" -a -z "$DISPLAY" ] ; then
		EMACS=`type emacs`
		EMACS=`expr "${EMACS}" : '^[^/]*\(/[^ )]*\)'`
		# this sort of assumes TERM=dmd or similar
		emacs ()
		{
			msg=n
			if mesg >/dev/null 2>&1 ; then msg=y; fi
			trap "trap 1 2 3 15; clearban; mesg $msg || true" 1 2 3 15
			OWBANNER=${WBANNER}
			WBANNER="GNU Emacs @ $UUNAME"
			setban
			mesg n || true
			$EMACS "$@"
			clearban
			mesg $msg || true
			trap 1 2 3 15
		}
	fi

	if expr "`type cu 2>/dev/null`" : '.* is .*/cu)*$' >/dev/null 2>&1 ; then
		CU=`type cu`
		CU=`expr "$CU" : '^[^/]*\(/[^ )]*\)'`
		cu ()
		{
			msg=n
			if mesg >/dev/null 2>&1 ; then msg=y; fi
			if [ "$TERM" = "dmd" -o "$TERM" = "dmd-myx" ] ; then
				trap "trap 1 2 3 15; mkmenu -; clearban; mesg $msg || true" 1 2 3 15
				myxsize -s
			else
				trap "trap 1 2 3 15; clearban; mesg $msg || true" 1 2 3 15
			fi
			OWBANNER=${WBANNER}
			WBANNER="cu $*"
			setban
			mesg n || true
			$CU "$@"
			clearban
			mesg $msg || true
			trap 1 2 3 15
		}
	fi

	if expr "`type ckermit 2>/dev/null`" : '.* is .*/ckermit)*$' >/dev/null 2>&1 ; then
		CKERMIT=`type ckermit`
		CKERMIT=`expr "$CKERMIT" : '^[^/]*\(/[^ )]*\)'`
		ckermit ()
		{
			msg=n
			if mesg >/dev/null 2>&1 ; then msg=y; fi
			if [ "$TERM" = "dmd" -o "$TERM" = "dmd-myx" ] ; then
				trap "trap 1 2 3 15; mkmenu -; clearban; mesg $msg || true" 1 2 3 15
				myxsize -s
			else
				trap "trap 1 2 3 15; clearban; mesg $msg || true" 1 2 3 15
			fi
			OWBANNER=${WBANNER}
			WBANNER="C-Kermit $*"
			setban
			mesg n || true
			$CKERMIT "$@"
			clearban
			mesg $msg || true
			trap 1 2 3 15
		}
	fi

	if expr "`type slogin 2>/dev/null`" : '.* is .*/slogin)*$' >/dev/null 2>&1 ; then
		SLOGIN=`type slogin`
		SLOGIN=`expr "$SLOGIN" : '^[^/]*\(/[^ )]*\)'`
		slogin ()
		{
			msg=n
			if mesg >/dev/null 2>&1 ; then msg=y; fi
			trap "trap 1 2 3 15; clearban; mesg $msg || true" 1 2 3 15
			OWBANNER=${WBANNER}
			WBANNER="slogin $*"
			setban
			mesg n || true
			$SLOGIN "$@"
			clearban
			mesg $msg || true
			trap 1 2 3 15
		}
	fi

	if expr "`type rlogin 2>/dev/null`" : '.* is .*/rlogin)*$' >/dev/null 2>&1 ; then
		RLOGIN=`type rlogin`
		RLOGIN=`expr "$RLOGIN" : '^[^/]*\(/[^ )]*\)'`
		rlogin ()
		{
			msg=n
			if mesg >/dev/null 2>&1 ; then msg=y; fi
			trap "trap 1 2 3 15; clearban; mesg $msg || true" 1 2 3 15
			OWBANNER=${WBANNER}
			WBANNER="rlogin $*"
			setban
			mesg n || true
			$RLOGIN "$@"
			clearban
			mesg $msg || true
			trap 1 2 3 15
		}
	fi

	if expr "`type telnet 2>/dev/null`" : '.* is .*/telnet)*$' >/dev/null 2>&1 ; then
		TELNET=`type telnet`
		TELNET=`expr "$TELNET" : '^[^/]*\(/[^ )]*\)'`
		telnet ()
		{
			msg=n
			if mesg >/dev/null 2>&1 ; then msg=y; fi
			if [ "$TERM" = "dmd" -o "$TERM" = "dmd-myx" ] ; then
				trap "trap 1 2 3 15; mkmenu -; clearban; mesg $msg || true" 1 2 3 15
				myxsize -s
			else
				trap "trap 1 2 3 15; clearban; mesg $msg || true" 1 2 3 15
			fi
			OWBANNER=${WBANNER}
			WBANNER="telnet $*"
			setban
			mesg n || true
			$TELNET "$@"
			clearban
			mesg $msg || true
			trap 1 2 3 15
		}
	fi

	if expr "`type mush 2>/dev/null`" : '.* is .*/mush)*$' >/dev/null 2>&1 ; then
		TELNET=`type mush`
		TELNET=`expr "$MUSH" : '^[^/]*\(/[^ )]*\)'`
		mushC ()
		{
			msg=n
			if mesg >/dev/null 2>&1 ; then msg=y; fi
			trap "trap 1 2 3 15; clearban; mesg $msg || true" 1 2 3 15
			OWBANNER=${WBANNER}
			WBANNER="MUSH $*"
			setban
			mesg n || true
			$MUSH -C "$@"
			clearban
			mesg $msg || true
			trap 1 2 3 15
		}
	fi

	if expr "`type nethack 2>/dev/null`" : '.* is .*/nethack)*$' >/dev/null 2>&1 ; then
		NETHACK=`type nethack`
		NETHACK=`expr "$NETHACK" : '^[^/]*\(/[^ )]*\))'`
		nethack ()
		{
			msg=n
			if mesg >/dev/null 2>&1 ; then msg=y; fi
			if [ "$TERM" = "dmd" -o "$TERM" = "dmd-myx" ] ; then
				trap "trap 1 2 3 15; loadfont thin.9x14; clearban; mesg $msg || true" 1 2 3 15
				loadfont rogue.9x18
			else
				trap "trap 1 2 3 15; clearban; mesg $msg || true" 1 2 3 15
			fi
			OWBANNER=${WBANNER}
			WBANNER="NetHack"
			setban
			mesg n || true
			$NETHACK "$@"
			clearban
			mesg $msg || true
			trap 1 2 3 15
		}
	fi

	if [ -x /usr/5bin/su ] ; then
		SU=/usr/5bin/su
	elif [ -x /usr/bin/su ] ; then
		SU=/usr/bin/su
	elif [ -x /bin/su ] ; then
		SU=/bin/su
	else
		SU=`type su`
		SU=`expr "$SU" : '^[^/]*\(/[^ )]*\)'`
	fi
	su ()
	{
		msg=n
		if mesg >/dev/null 2>&1 ; then msg=y; fi
		trap "trap 1 2 3 15; clearban; mesg $msg || true" 1 2 3 15
		OWBANNER=${WBANNER}
		WBANNER="SU ${*-root}"
		setban
		mesg n || true
		$SU "$@"
		clearban
		mesg $msg || true
		trap 1 2 3 15
	}

fi

# Transform id(1)'s output into useful shell variable assignments
#
# UGLY, but it works
#
# NOTE:  there's a trick in here -- if there's no group name for your GID then
# the final expression parameter won't do anything.  However since the extra
# "groups=..." stuff (which may have had more word-surrounded parens) has
# already been trimmed off the end the only thing that'll be left is the
# original "gid=20" string, so $group simply won't be set, so afterward it is
# set to $gid instead.
#
eval "`id | sed -e 's/ groups=.*$//' \
		 -e 's/(\([^) ]*\)) / user=\1 /' \
		 -e 's/(\([^) ]*\))/ group=\1/'`"
: ${group:=${gid}}

if [ "$uid" -eq 0 ] ; then
	#
	# we always want persistent (and shared) history for 'su'
	#
	ROOT_HOME=`get_user_home root`
	if [ -n "$HISTFILE" ]; then
		HISTFILE="${ROOT_HOME}/`basename $HISTFILE`"
	else
		HISTFILE="${ROOT_HOME}/.sh_history"
	fi
	if [ ! -f $HISTFILE ]; then
		touch $HISTFILE
	fi
	# see also ~/.kshlogin
	HISTSIZE=2000
	export HISTSIZE

	PRE_SU_PATH=$PATH

	# XXX this is for older macos systems (e.g. 10.13.6) with Joyent
	# packages where the 'nbase' build of awk version 20121220 dumps core on
	# the script in removedups!  (same version as /opt/pkg/bin/nawk works!)
	#
	dirremove PATH /opt/pkg/nbase/bin

	removedups PATH

	# got to get rid of lone ":" or any "." in PATH
	PATH=`echo $PATH | sed -e 's/::/:/g'	\
				-e 's/^://'	\
				-e 's/:$//'	\
				-e 's/^\.://'	\
				-e 's/:\.://g'	\
				-e 's/:\.$//'`
	if [ -n "$SU_FROM" ]; then
		# xxx this is a trick, and only necessary on machines
		# without my fixed "su" -- we reset LOGNAME in case
		# this was a proper and secure 'su' (i.e. one that
		# reset the environment, especially and including
		# $HOME, etc., including of course $LOGNAME).  This
		# does two things.  First, and most important, though
		# most dangerous, it tricks emacs, for now, into
		# finding ~$LOGNAME/.emacs[.elc].  Second it
		# simplifies the next PATH cleanup step....
		#
		# we set USER to "root" explicitly even if the user
		# did not use "su -l" as they should have...
		#
		LOGNAME=$SU_FROM
		export LOGNAME
		USER="root"
		export USER
	fi
	if [ -n "$SUDO_USER" ]; then
		# xxx this is a similar trick for OSX and Linux braindamage
		LOGNAME=$SUDO_USER
		export LOGNAME
		USER="root"
		export USER
	fi
	# also get rid of the login user's ~/{usr/bin,bin,go/bin} because they
	# are usually first, and they usually contains personal hacks or test
	# programs that are probably not safe to use as root, and (if this is
	# not ~$SU_FROM/.kshrc then ~$SU_FROM/bin may also contain trojans or
	# worse)
	#
	# n.b.:  this only works properly if the shell can expand "~user",
	# though if eventually neede it could be changed to use the
	# get_user_home function above....
	#
	LOGNAMEPATH=`eval echo ~$LOGNAME/usr/bin`
	dirremove PATH ${LOGNAMEPATH}
	LOGNAMEPATH=`eval echo ~$LOGNAME/bin`
	dirremove PATH ${LOGNAMEPATH}
	LOGNAMEPATH=`eval echo ~$LOGNAME/go/bin`
	dirremove PATH ${LOGNAMEPATH}

	unset LOGNAMEPATH

	SU_POST_CLEAN_PATH=$PATH

	# must have X11BIN before openwin if newer X on system....
	dirappend PATH /usr/lbin /usr/ucb ${X11BIN}

	if [ -z "$UUNAME" ]; then
		# xxx don't bother with trying the real uuname -l
		UUNAME=`hostname`
		export UUNAME
	fi
	if [ -z "$HOSTNAME" ]; then
		HOSTNAME=`hostname`
		export HOSTNAME
	fi
	if [ -z "$DOMAINNAME" ]; then
		DOMAINNAME=`get_domainname`
		export DOMAINNAME
	fi

	if $ISSUN ; then
		PATH=`echo $PATH | sed 's/^\/bin://'`
		if [ `uname -r | sed 's/^\([0-9]*\).*$/\1/'` -lt 5 ] ; then
			if [ "X$LOGNAME" != "Xroot" ] ; then
				dirprepend PATH /usr/5bin
			else
				dirappend PATH /usr/5bin
			fi
		else
			dirprepend PATH /opt/SUNWspro/bin
		fi
		# XXX FIXME: should use OPENWINHOME ???
		# XXX FIXME: should only do this if DISPLAY set???
		dirappend PATH /usr/openwin/bin /usr/openwin/demo
		dirappend MANPATH /usr/openwin/share/man
	fi
	if [ ! -d /usr/sbin ] ; then
		dirprepend PATH /usr/etc	# only old BSDs
	fi
	if [ ! -d /sbin -a ! -d /usr/etc ] ; then
		dirprepend PATH /etc		# only really old systems...
		dirappend PATH /usr/lib		# ditto
	fi
	dirprepend PATH /sbin /usr/sbin $LOCAL/sbin $PKG/sbin $CONTRIB/sbin $SLASHOPT/sbin $GNU/sbin
	if [ -n "${UUCPSPOOLDIR}" ]; then
		dirappend PATH /usr/libexec/uucp /usr/lib/uucp
	fi
	dirappend PATH $ROOT_HOME/bin

	if [ -z "$UUNAME" ]; then
		if type uuname >/dev/null 2>&1 ; then
			UUNAME=`uuname -l`
		else
			UUNAME=`hostname`
		fi
		export UUNAME
	fi

	set_LOCAL_et_al

	if ismpx -s || [ "$TERM" = "dmd-myx" ] ; then
		# xxx should do this in setban...
		MYXBAN_R='$user:$group($LOGNAME)@$UUNAME[$LEV]:$TTYN'
		dirappend PATH $DMD/bin $DMDSGS/bin/3b5 $DMD/local/bin
	fi

	: ${PSc:="#"}
	MAILPATH=${MAILDIR}/${LOGNAME}:${MAILDOR}/root:${MAILDIR}/uucp:${MAILDIR}/usenet
	# XXX assume any emacsclient will try to use the user's server process
	case "$VISUAL" in
	*emacsclient*)
		VISUAL="${MY_EMACS} -nw"
		export VISUAL
		;;
	esac
	case "$EDITOR" in
	*emacsclient*)
		EDITOR="${MY_EMACS} -nw"
		export EDITOR
		;;
	esac
	# just make damn sure PAGER is set...
	if type less >/dev/null 2>&1; then
		PAGER="less"
		LESS="-M"
		export LESS
	elif [ -x /usr/xpg4/bin/more ] ; then
		# SunOS-5's, at least, has the 'G' command!
		PAGER="/usr/xpg4/bin/more"
		# use '-s' as it can't be turned on later during runtime
		MORE="-s"
		export MORE
	elif [ "${PAGER##*/}" = "more" ] ; then
		PAGER="more"
		# use '-s' as it can't be turned on later during runtime
		MORE="-sw"
		export MORE
	else
		# meow
		PAGER="cat"
	fi
	export PAGER
	if [ "$PAGER" = "less" ]; then
		MANPAGER="$PAGER -Rsi"
		export MANPAGER
	fi

	if [ -n "$DISPLAY" -a -z "$XAUTHORITY" ]; then
		#
		# XXX if root is using this .kshrc then perhaps we
		# should try copying the "xauth" information for the
		# current display to $HOME/.Xauthority instead of just
		# pointing at it...  but why bother???
		#
		# n.b.:  this only works properly if the shell can expand
		# "~user"
		#
		XAUTHORITY=`eval echo ~${SU_FROM}/.Xauthority`
		export XAUTHORITY
	fi

	unset -f krcmd || true
	function krcmd
	{
		# WARNING: this version kills everyone's rcmd procs!
		kill -9 `ps -axlc | awk '$3 == 1 && $13 == "rcmd" {print $2}'`
	}
	# I don't know if this is right, or not, but let's try for now...
	cd
	OWBANNER=${WBANNER}
	WBANNER="SU `basename ${SHELL}`"
	setban
elif [ "$user" != "$LOGNAME" ] ; then
	if ismpx -s || [ "$TERM" = "dmd-myx" ] ; then
		# xxx should do this in setban...
		MYXBAN_R='$user:$group($LOGNAME)@$UUNAME[$LEV]:$TTYN'
	fi
	: ${PSc:='$'}
else
	if ismpx -s || [ "$TERM" = "dmd-myx" ] ; then
		# xxx should do this in setban...
		MYXBAN_R='$LOGNAME{$group}@$UUNAME[$LEV]:$TTYN'
	fi
	: ${PSc:='$'}
fi
if [ -z "${D_PS1}" ]; then
	PS1="${PS1} ${PSc} "
fi

if [ "$user" = usenet -o "$group" = news ] ; then
	dirprepend PATH $LOCAL/lib/newsbin $LOCAL/lib/newsbin/maint $LOCAL/lib/newsbin/input
fi
if [ "$user" = cyrus -o "$group" = cyrus ] ; then
	dirprepend PATH $LOCAL/cyrus/bin $PKG/cyrus/bin $SLASHOPT/cyrus/bin $CONTRIB/cyrus/bin
fi

D_PS1="done"

#
# now some helpful functions
#

if [ -f /usr/share/misc/na.phone ]; then
	areacode ()
	{
		grep ${1+"$@"} /usr/share/misc/*.phone
	}
fi

errno ()
{
	grep "^#define[ 	]*[A-Z][A-Z]*[ 	]*$1[ 	]" ${SDKPREFIX}/usr/include/sys/errno.h
}

file2imgsz ()
{
	# file(1), as of 5.39 at least, displays the pixel size of a JPG in a
	# "field" matching "[0-9]*x[0-9]*," unless the "field" starts with the
	# word "density".... (fields are (un)officially comma separated, but we
	# can split using the normal AWK FS and stilll easily find the match)
	#
	awk '{file=$1; for (f=1; f<NF; f++) {if ($(f-1) != "density" && $f ~ /[0-9]*x[0-9]*,/) {print file $f}}}'
}

hex2d ()
{
	# N.B.:  this is only usable if the shell supports arithmetic expansions
	#
	# xxx NetBSD ksh (and most/all other pdksh derivatives) don't seem to
	# understand octal.  NetBSD sh does understand strict octal (with a
	# leading 0), but ksh93 does a (not-so-)"smart" conversion and if any
	# digits are >7 it will treat numbers with a leading zero as if they are
	# decimal!  (All require a leading "0x" to recognize hex -- should we
	# prepend it if missing?  Probably not.)
	#
	echo "$(($@))"
}

maillog ()
{
	# Warning:  less (at least up to v. 394) has a limitation of about 95
	# chars (or perhaps UNGOT_SIZE, 100) to the length of the '-p'
	# parameter.  (xxx otherwise I would also include words like "core",
	# "signal", and "trace")
	#
	$PAGER -enM -p ": \[[0-9]+\] (\[.+\] )?((remote[A-Z ]*:)|remote ..LO: (rejected: inv[^:]*:|refusing) )|^.*kill.*" +G $MAILLOG ${!+"$@"}
}

malias ()
{
	grep "alias[ 	]$*" $LOCAL/lib/mush/Mail.rc ${HOME}/.mushrc
}

signm ()
{
	grep "^#define[ 	]*SIG.*[ 	]*${1}[ 	]" ${SDKPREFIX}/usr/include/sys/signal.h
}

signo ()
{
	grep -i "^#define[ 	]*.*${1}[ 	]*[0-9]" ${SDKPREFIX}/usr/include/sys/signal.h
}

# trivial hack to quickly search a source tree where traditional globbing would
# exceed ARG_MAX
#
# Requires a find with the SysVR4 "-exec ... {} ... +" feature.  (now also
# mandated by SUSv3, aka IEEE 1003.1-2001/2004)
#
# OpenGroup gives the following example of using this showing how arguments with
# whitespace, including newlines, are preserved:
#
#	find . ! -name . -prune -name '*.old' -exec \
#	    sh -c 'mv "$@" ../old/' sh {} +
#
# Following is a command which must succeed on any POSIX conformant system but
# which will fail if find lacks support for '+' due to a missing ';' argument,
# so could be used to detect incompatability and thus make it possible to
# provide an alternative implementation if desired:
#
#	find /dev/null -exec true '{}' +
#
# The most portable alternative might be to use 'sed' and 'xargs'.  Note the
# 'sed' command in the pipeline is mandatory.  Contrary to popular belief, xargs
# does NOT accept newline-delimited lists.  Rather it accepts shell-quoted
# lists, i.e. the input list is separated by whitespace and all internal
# whitespace must be quoted.  To avoid this the following command simply quotes
# _all_ characters with backslashes to satisfy this requirement, protecting
# embedded whitespace in filenames.
#
#	find ... | sed 's/./\\&/g' | xargs command
#
# The best alternative to the 'sed' is to use 'find -print0', but that still
# requires a pipeline to 'xargs', and it requires both a 'find' with '-print0'
# and an 'xargs' with '-0' (which are non-standard but nearly ubiquitous now)
# (i.e. to support printing and reading NUL separated values).
#
# Some versions of 'find' (notably on NetBSD) support '-printx' which does the
# backslash escaping directly itself, and as with the use of 'sed' shown above,
# 'xargs' supports this escaping by default (as per POSIX).  (It is indeed very
# weird that POSIX 'find' does not (yet) have the corresponding '-printx'.)
#
# So, this is the faster, standards-conformant, alternative to "find ... -print0
# | xargs -0 ..." or "find ... -printx | xargs ..."
#
srcfgrep ()
{
	find . \( -type d \( -name CVS -or -name .git -or -name .svn -or -name build -or -name 'build-*' -or -name autom4te.cache \) -prune \) -or -type f ! -name '.#*' ! -name '#*#' ! -name '*~' ! -name '.*ignore' ! -name '[Tt][Aa][Gg][Ss]' -exec fgrep ${1+"${@}"} {} +
}

trim ()
{
	# AWK trickery to "canonicalize" whitespace in text.
	#
	# In AWK a pattern is an expression, and so just giving a non-zero value
	# says this expression matched, and if there's no action part to the
	# statement then the default action (if the pattern expression is true)
	# is to print the input line (i.e. $0), thus AWK can be cat:
	#
	#	awk 1
	#
	# The trick here is to re-assign the first field to itself -- this
	# causes AWK to rebuild the whole input line by first splitting it into
	# fields (with FS, space by default), then rebuilding $0 by putting the
	# fields back together using OFS (space by default).
	#
	# We put this together with two statements, the first with a missing
	# pattern (which always matches), and the second with a missing action
	# and a non-zero (i.e. "true") value as the pattern expression:
	#
	_USAGE="Usage: trim [-F fs] [-v var=value] [file ...]"
	_HELP="${_USAGE}\n
		\t-F fs\t\tSet the input field separator FS to the regular expression fs.\n
		\t-v var=value\tAssign the value to the variable. (e.g. OFS=:)\n
		Trim is a wrapper on a small AWK program that splits and recombines all fields\n
		in each input line thus removing all leading and trailing whitespace (or the\n
		specified field separator value) and collapsing all whitespace (or FS) between\n
		each field."
	_awk_opts=
	OPTIND="1"
	while getopts "F:hv:" OPTCH
	do
		case ${OPTCH} in
		F|v)
			_awk_opts="${_awk_opts} -${OPTCH} '${OPTARG}'"
			;;
		h)
			echo ${_HELP}
			return 0
			;;
		*)
			echo ${_USAGE} >&2
			return 2
			;;
		esac
	done
	shift `expr ${OPTIND} - 1`

	eval awk ${_awk_opts} "'{\$1 = \$1};1'" ${1+"$@"}
	_rc=$?

	unset _USAGE _HELP _awk_opts OPTCH

	return ${_rc}
}

typeof ()
{
	if [ -z "$LLIBDIR" ]; then
		if $ISSUN; then
			LLIBDIR=/usr/lib/lint
		elif [ -d /usr/libdata/lint ]; then
			# XXX not quite so useful when these are for xlint...
			LLIBDIR=/usr/libdata/lint
		else
			LLIBDIR=/usr/lib
		fi
	fi
	# should expand to allow '-l{lib}'
	egrep -i "$1" $LLIBDIR/llib-l*
}

zhead ()
{
	zcat ${1+"${@}"} | head
}

#
# the rest are implementations of favourite ksh aliases as functions
#
# (which can be removed by "rm_alias_funcs")
#
# functions are (maybe?) more overhead than aliases in shells with aliases[???]
#

rm_alias_funcs ()
{
	# note: '-f' is only in modern sh as well as ksh and bash, but that's
	# where this is used
	#
	unset -f blsqueeze blstrip ds e elc l la ll lli lla llia llr llir llra llira lr lra lsa nstty rstty wcvs || true
	if [ -x /usr/ucb/rsh -a -x /bin/rsh ] ; then
		unset -f rsh || true
	fi
	if [ -n "$UUCPSPOOLDIR" ]; then
		unset -f uufollow || true
	fi
}
rm_func_aliases ()
{
	type alias >/dev/null 2>&1 || return 0
	for _a in uufollow rsh blsqueeze blstrip ds e elc l la ll lli lla llia llr llir llra llira lr lra lsa nstty rstty wcvs; do
		if alias ${_a} >/dev/null 2>&1; then
			unalias ${_a}
		fi
	done
	unset _a
}

# .... and in case we are sourcing this file for a second time....
#
rm_alias_funcs
rm_func_aliases

if [ -n "$UUCPSPOOLDIR" ]; then
	uufollow ()
	{
		xtail $UUCPSPOOLDIR/.[AL]*/*
	}
fi
if [ -x /usr/ucb/rsh -a -x /bin/rsh ] ; then
	# /bin/rsh is likely the restricted shell!
	rsh ()
	{
		/usr/ucb/rsh ${1+"$@"}
	}
fi

blsqueeze ()
{
	sed "/./,/^$/!d"
}
blstrip ()
{
	sed "/./!d"
}
ds ()
{
	$PAGER ${1+"$@"}
}
e ()
{
	${VISUAL:-$EDITOR} ${1+"$@"}
}
elc ()
{
	${MY_EMACS} -batch -q -no-site-file -f batch-byte-compile
}
l ()
{
	${LS} -CF ${1+"$@"}
}
la ()
{
	${LS} -CFa ${1+"$@"}
}
ll ()
{
	${LS} -l${LS_O}s ${1+"$@"}
}
lli ()
{
	${LS} -li${LS_O}s ${1+"$@"}
}
lla ()
{
	${LS} -l${LS_O}sa ${1+"$@"}
}
llia ()
{
	${LS} -li${LS_O}sa ${1+"$@"}
}
llr ()
{
	${LS} -l${LS_O}sR ${1+"$@"}
}
llir ()
{
	${LS} -li${LS_O}sR ${1+"$@"}
}
llra ()
{
	${LS} -l${LS_O}saR ${1+"$@"}
}
llira ()
{
	${LS} -li${LS_O}saR ${1+"$@"}
}
lr ()
{
	${LS} -CFR ${1+"$@"}
}
lra ()
{
	${LS} -CFRa ${1+"$@"}
}
lsa ()
{
	${LS} -a ${1+"$@"}
}
nstty ()
{
	stty sane intr "^?" erase "^h" kill "^u" echoe echok
	echo "(use 'tput reset', or 'tabs -8' to reset tabs, etc.)"
}
rstty ()
{
	stty $SANE
	echo "(use 'tput reset', and/or 'tabs -8' to reset tabs, etc.)"
}
sshsendkey ()
{
	# not all systems have ssh-copy-id(1)
	cat ${HOME}/.ssh/id_rsa.pub | ssh $1 '
		mkdir -pm 700 $HOME/.ssh
		cat >> $HOME/.ssh/authorized_keys
		chmod 600 $HOME/.ssh/authorized_keys
	'
}
wcvs ()
{
	echo $CVSROOT
}

# done....
