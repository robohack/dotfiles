#
#	.shrc - per-shell startup stuff for all shells
#
# This file is normally only used directly by bosh(1), either if $ENV is not set
# or if $ENV is set to $HOME/.shrc, but it is never used otherwise as $ENVFILE
# (i.e. $ENV).  However it is shared and sourced by all that are set as $ENVFILE
# (including ~/.ashrc normally set as $ENV for bosh(1) et al).
#
# Note:  Most of this should be compatible with some pre-POSIX shells.  Notably:
#
#	- don't use $() for command expansion (ever!  except when running ksh)
#	- don't use '!' in pipelines for flow-control statements
#	- mostly no arithmetic expressions
#	- mostly no suffix or prefix patterns
#	- don't use ~ for pathname expansion (use $HOME)
#	- don't use "export VAR=value"
#	- function names must not include hyphens ('-') (ATT Ksh barfs)
#
# It may also assume .profile has already set some things, though it should not.
# For the most part variables that are used herein should be set herein.
#
# Maybe even more environment variable settings should move here, especially any
# that are only used by functions here, e.g. as was done with MAILLOG
# (e.g. $PAGER).
#
# Files referenced:
#
#	$HOME/.ashtype		- sourced if no "type" command, if it is readable
#	$HOME/.shpwd		- sourced, if it is readable
#
#ident	"@(#)HOME:.shrc	37.63	25/12/08 12:53:44 (woods)"

#echo $0: in $HOME/.shrc!

if [ -z "${SHELL}" ]; then
	#
	# The current shell is likely plain old Bourne (Heirloom) shell
	#
	# XXX too bad we can't get the true full pathname
	#
	SHELL=`expr "$0" : '-*\(.*\)'`
fi

# Provide 'type' for shells (i.e. early ash) that don't have it.
#
# Note:  early ash reads $SHINIT at start, except if is is a login shell or it
# is called with "sh file" (but this feature is not used -- early ash is too
# rare, and besides we want to source .ashtype even if not interactive, e.g. if
# called by onx11server).
#
# The I/O re-direction doesn't actually get rid of the "type: not found" message
# from the old Ash implementation...  Perhaps it parses the whole line first?
#
# XXX but maybe it would if we redirected stderr within the subshell too, as we
# must do for GNU Bash?  Can't test without an old ash(1) any more though!
#
if ( type type > /dev/null 2>&1 ) > /dev/null 2>&1 ; then
	:
elif [ -r ${HOME}/.ashtype ]; then
	. ${HOME}/.ashtype
fi

#
#	N.B.:  the rest of the file is for "interactive" and login shells only!
#

sh_is_interactive=false
sh_is_login=false
case "$-" in
*i*)
	sh_is_interactive=true
	;;
esac
case "$0" in
-`basename $SHELL`)
	# Also setting $sh_is_interactive is really just for (Schily and
	# Heirloom) Bourne Shell which does not put "i" in $- until after
	# ~/.profile has been sourced, not that they read $ENV by themselves!
	#
	# N.B.:  This presumes of course that login shells are, by definition,
	# interactive.
	#
	# XXX this can be fooled with:  SHELL=/bin/sh sh -c 'echo $0' -sh foo!
	#
	sh_is_interactive=true
	sh_is_login=true
	;;
esac
case "$-" in
*l*)
	# Some shells can be invoked as login shells with '-l' (pdksh, bash).
	#
	sh_is_interactive=true
	sh_is_login=true
	;;
esac

if ${sh_is_interactive} || ${sh_is_login} || ${FROM_DOT_PROFILE:-false}; then
	: OK
else
	return 0
fi

# Everything else in this file is for interactive (or explicitly chosen) use
# only, but $ENV is set to just the plain filename of this file because ash(1)
# and its derivatives do not have arrays and so cannot use the ksh(1)
# ${ENVFILE[]} trick, so we must return above.
#
# This big comment follows the "return 0" above so that it does not have to be
# read and parsed by non-interactive shells!
#
# Note: $sh_is_interactive is still not a reliable definition for older shells.
#
# POSIX(Issue 7 and Issue 8) says:
#
#	If the -i option is present, or if there are no operands and the shell's
#	standard input and standard error are attached to a terminal, the shell
#	is considered to be interactive.
#
# Many implementations also add the caveat:  "and the -c option is not present".
# This is more or less covered by the "and there are no operands" part, but....
#
# POSIX(Issue 8) does now add to the definition of "$-":
#
#	It is unspecified whether the -c and -s options are included in the
#	expansion of "$-".  The -i option shall be included in "$-" if the shell
#	is interactive, regardless of whether it was specified on invocation.
#
# So, for shells that don't add 'i' to $- the tests above are inadequate.
#
# If we could reliably test if the shell was reading commands from stdin
# (e.g. acting as if '-s' was given and there was on '-c'), then if stdin and
# stderr are terminals we would know the shell is in interactive mode.  However
# NetBSD sh(1), and presumably most other ash(1) derivatives, along with the
# original Bourne Shell and its derivatives, have tested if stdin and _stdout_
# are TTYs to determine their interactactive-ness.  Ksh introduced the change to
# test _stderr_ some time before ksh88e as it allows "sh | tee x" to behave the
# same as "sh".  This was fixed in NetBSD sh(1) as of 2017-07-24 and netbsd-8
# (unfortunately after the introduction of $NETBSD_SHELL though).
#
# However since most shells also don't add either "c" or "s" to $- this is not
# possible.  Worse yet the original Bourne Shell and its derivatives, including
# even the latest ksh93, add "s" to $- even when they shouldn't (but only when
# there are no further "positional" arguments):
#
#	 sh -c 'echo $0:  \$-=\"$-\"'
#
# Note that '-c' is a plain flag ("c" in getopts, i.e. no parameter) which
# simply declares how remaining arguments are to be treated after any remaining
# option arguments are processed.  The first remaining argument is treated as a
# string to be parsed as a script, and the next of any more remaining arguments
# is set as $0, with the rest set as positional parameters in $@ (i.e. as if
# 'set -- args ..." were executed) for that script's use.
#
# N.B.  This all really doesn't matter in the real world though -- we can (for
# now) assume all shells that support $ENV will stick 'i' in $- if they are
# interactive (even when -i is not given as an argument), and furthermore shells
# which expand and source $ENV even when not interactive are the only ones we
# really care about anyway.  That said, pdksh and its derivatives, including
# NetBSD ksh(1), (which all do source $ENV all the time) can use the old AT&T
# Ksh array trick as they support arrays, so even they don't need any internal
# tests.  This is all really for NetBSD sh(1) (when it is not in POSIX mode) and
# other older Ash variants (not dash).

# note:  $FROM_DOT_PROFILE is for non-interactive, non-login, uses such as
# directly sourcing ~/.profile e.g. in ~/.xinitrc and from a remotely invoked
# command-line, as is done in onx11server, and getting the definition of
# onx11server, as well as some other environment variable setup, is of course
# why we need this escape hatch in the first place.
#
# xxx the "|| $sh_is_login" is currently redundant -- all login shells are also
# considered to be interactive shells in the tests above.
#

#echo $0: still in $HOME/.shrc!

# n.b.: /etc/shrc is liable to mess with PS1 for interactive shells....
SAVE_PS1="${PS1}"
if [ -f /etc/shrc ]; then
        . /etc/shrc
fi
PS1="${SAVE_PS1}"

# do this early so everything else can use it if needed
#
HAVEX=false
if type xinit >/dev/null 2>&1; then
	HAVEX=true
fi

# we start with a default of true, but if tty fails, we set it to false
#
# $ISATTY is basically a "memoization" to optimize for executing tty(1)
#
# xxx Hmmmm.... "test -t" also works all the way back to v7.
#
ISATTY="test -t"
TTY=`tty` || ISATTY="false"	# "not a tty" if not...

# This file sets D_PS1 at the end to avoid clobbering any .*shrc's new value.
#
# XXX In a sense this is an include guard and maybe we could use it as such?
#
if [ -z "${D_PS1}" ]; then
	# N.B.:  this will be possibly reset, then appended to....
	PS1=""
fi

# PS2="> "
# PS3="#? "
# PS4="+ "

is_bash ()
{
	[ ${RANDOM:-0} -ne ${RANDOM:-0} ] && [ -n "${BASH}" ]
}

is_ksh ()
{
	if [ ${RANDOM:-0} -ne ${RANDOM:-0} ] && [ -z "${BASH}" ]; then
		case "${KSH_VERSION}" in
		"Version"*)
			return 0 # likely att ksh
			;;
		*"MIRBSD"*)
			return 0 # mksh
			;;
		*"PD"*"KSH"*)
			return 0 # likely pdksh or some other derivative
			;;
		*)
			return 1
			;;
		esac
	else
		return 1
	fi
}

is_attksh ()
{
	is_bash && return 1

	# ksh93 and [p]bosh
	_sh_version=`eval 'echo "${.sh.version}"' 2>/dev/null`
	# [p]bosh only
	_sh_shell=`eval 'echo "${.sh.shell}"' 2>/dev/null`

	[ -n "${_sh_version}" ] && [ -z "${_sh_shell}" ]
	_rc=$?
	unset _sh_shell _sh_version

	return ${_rc}
}

is_ash ()
{
	is_ksh && return 1
	is_bash && return 1
	# older Ash didn't have $RANDOM?
	[ "`echo ~`" = "${HOME}" ]
}

is_bourne_sh ()
{
	is_ash && return 1
	[ "`echo ~`" != "${HOME}" ] && [ -z "${RANDOM}" ]
}

is_posixish_sh ()
{
	[ "`echo ~`" = "${HOME}" ] && [ ${RANDOM:-0} -eq ${RANDOM:-0} ]
}

is_schily_sh ()
{
	_sh_shell=`eval 'echo "${.sh.shell}"' 2>/dev/null`

	test -n "${_sh_shell}"
	_rc=$?
	unset _sh_shell

	return ${_rc}
}

if [ -r /var/log/smail/logfile ] ; then
	MAILLOG="/var/log/smail/logfile"
elif [ -r ${LOCAL}/var/log/smail/logfile ] ; then
	MAILLOG=${LOCAL}/var/log/smail/logfile
else
	MAILLOG="/var/log/smail/logfile"
fi
export MAILLOG

# always use ``$echo'' if any of the other variables are used...
#	$nl - print a newline (always required at end of line if desired)
#	$n - option to turn off final newline
#	$c - escape sequence to turn off final newline
# usage for a prompt is:
#	$echo $n "prompt: $c"
# and for a normal line
#	$echo "message$nl"
#
# Don't pretend to have print or printf if they are not builtin
#
HAVEPRINT=false
if expr "`type print 2>/dev/null`" : '^print is a shell ' > /dev/null 2>&1 ; then
	HAVEPRINT=true
fi
HAVEPRINTF=false
if expr "`type printf 2>/dev/null`" : '^printf is a shell ' > /dev/null 2>&1 ; then
	HAVEPRINTF=true
fi
if ${HAVEPRINT} ; then
	#
	# XXX Ksh "print" is a horrible mess of unusability, but, if it is
	# builtin....
	#
	# XXX in theory "print -R", if available, is a better emulation of BSD
	# echo with '-n', but for $echo it doesn't really matter....
	#
	echo=print
	nl='\n'
	n='-n'
	# XXX in theory '\c' is equivalent of '-n' in all Ksh-compatible shells
	c=''
elif ${HAVEPRINTF} ; then
	echo=printf
	nl='\n'
	n=''
	c=''
	# for fun:
	portable_echo ()
	{
		[ "$1" = -n ] && { shift; FMT="%s"; } || FMT="%s\n"
		printf "$FMT" ${1+"$@"}
	}
else
	# NOTE:  Assume if "echo" is builtin that it is OK and do not prefer an
	# external "echo" for $echo, even if that is more capable (though that
	# is not likely ever true).
	#
	echo=echo
	c=`echo "xyzzy\c" | sed 's/[^c]//g'`
	if test -n "${c}" ; then
		# BSD echo
		nl=''
		n='-n'
		c=''
	else
		# (SysVr2 or newer) Bourne Shell echo
		# (some may have -n, but ignore that as we know we have '\c')
		nl='\n'
		n=''
		c='\c'
	fi
	# n.b.:  ancient echo (V7) is not supportable for this use!
fi
#
# NOTE: we don't export $echo et al -- they're just in the current shell

# A magic non-forking test for existence of a path component in a path-style
# (colon-separated) variable
#
in_pathvar_p() {
	if [ $# -le 1 -o -z "${1}" ] ; then
		echo "Usage: in_pathvar_p pathvar directory" >&2
		return 2
	fi
	eval "case :\$${1}: in *:${2}:*) return 0;; *) return 1;; esac"
}

dirappend ()
{
	local varname varvalue
	local notexists=true

	if [ $# -le 1 -o -z "${1}" ] ; then
		echo "Usage: dirappend [-e] pathvar directory [...]" >&2
		return 2
	fi
	if [ "${1}" = "-e" ]; then
		notexists=false
		shift
	fi
	varname=${1}
	shift
	while [ $# -gt 0 ] ; do
		if $notexists || [ -d ${1} ]; then
			eval varvalue='${'${varname}'}'
			if in_pathvar_p ${varname} "${1}" ; then
				:
			else
				if [ -z "${varvalue}" ]; then
					eval ${varname}='"${1}"'
				else
					eval ${varname}='${'${varname}'}":${1}"'
				fi
			fi
		fi
		shift
	done
	unset varname varvalue notexists
}

dirprepend ()
{
	local varname varvalue
	local notexists=true

	if [ $# -le 1 -o -z "${1}" ] ; then
		echo "Usage: dirprepend [-e] pathvar directory [...]" >&2
		return 2
	fi
	if [ "${1}" = "-e" ]; then
		notexists=false
		shift
	fi
	varname=${1}
	shift
	while [ $# -gt 0 ] ; do
		if $notexists || [ -d ${1} ]; then
			eval varvalue='${'${varname}'}'
			if in_pathvar_p $varname "${1}" ; then
				:
			else
				if [ -z "${varvalue}" ]; then
					eval ${varname}='"${1}"'
				else
					eval ${varname}='"${1}":${'${varname}'}'
				fi
			fi
		fi
		shift
	done
	unset varname varvalue notexists
}

dirremove ()
{
	local varname

	if [ $# -le 1 -o -z "${1}" ] ; then
		echo "Usage: dirremove pathvar eRE-directory [...]" >&2
		return 2
	fi
	varname=${1}
	shift
	while [ $# -gt 0 ] ; do
		if [ "$1" = ":" -o -z "$1" ] ; then
			eval $varname=`eval echo '$'$varname | sed -Ee 's|::||g' -e 's|^:+||' -e 's|:+$||'`
		else
			# n.b. don't use in_pathvar_p to allow eREs in directory
			eval ${varname}=`eval echo :'$'${varname}: | sed -Ee "s|^${1}:||g" -e "s|:${1}:|:|g" -e 's|^:+||' -e 's|:+$||'`
		fi
		shift
	done
	unset varname
}

# maybe another way, but one at a time....
#
pathvarremove ()
{
	local pathvar newpath gonner

	if [ $# -le 1 -o -z "${1}" ] ; then
		echo "Usage: pathvarremove pathvar directory" >&2
		return 2
	fi
	pathvar=${1}
	gonner=${2}
	#
	# N.B.:  ast-ksh/ksh93(???) and bash can use ${!vname} to avoid the set
	# and command substitution using eval:
	#
	#	typeset IFS=:
	#	for dir in ${!pathvar}; do
	#
	# note that the set is necessary to allow eval to expand the pathvar as
	# a variable name, and then to avoid mishandling path components with
	# normal $IFS characters embedded.
	#
	set -- `IFS=':'; eval echo '$'${pathvar}`
	newpath=""
	for dir in ${1+"$@"}; do
		if  [ "${dir}" != "${gonner}" ]; then
			newpath=${newpath:+${newpath}':'}${dir}
		fi
	done
	eval ${pathvar}="${newpath}"

	unset pathvar newpath gonner
}

removedups ()
{
	local varname varvalue nvalue rc

	if [ $# -lt 1 -o -z "${1}" ] ; then
		echo "Usage: removedups pathvar" >&2
		return 2
	fi
	varname=${1}
	eval varvalue='${'${varname}'}'
	nvalue=`echo "${varvalue}" | awk -v RS=: -v ORS=: '
		BEGIN {
			A[""] = 0;
		}
		{
			# removing the newline is necessary in case the last
			# element is a duplicate
			#
			sub(/\n$/, "");
			if (! A[$0]) {
				A[$0]=1;
				printf("%s%s", ((NR == 1) ? "" : ORS ), $0);
			}
		}'
	`
	# XXX 'nbase' awk version 20121220 from Joyent packages core-dumps on macos
	rc=$?
	if [ ${rc} -ne 0 ]; then
		echo "removedups: awk failed: $rc" >&2
		unset varname varvalue nvalue rc
		return 1
	fi
	if [ -n "${nvalue}" ]; then
		eval ${varname}="${nvalue}"
	else
		echo "removedups: empty result!" >&2
		unset varname varvalue nvalue rc
		return 1
	fi
	unset varname varvalue nvalue rc
}

# ToDo:  consider rewriting the above so they accept '-F sepchar' and then the
# following can be eliminated?  (but what about the check for .../fonts.dir?
# maybe another option '-f file' to say the directory must contain a file named
# "file"?)

in_fppathvar_p() {
	if [ $# -le 1 -o -z "${1}" ] ; then
		echo "Usage: in_fppathvar_p fppathvar directory [...]" >&2
		return 2
	fi
	eval "case ,\$${1}, in *,${2},*) return 0;; *) return 1;; esac"
}

fpappend ()
{
	local varname varvalue

	if [ $# -le 1 -o -z "${1}" ] ; then
		echo "Usage: fpappend fppathvar directory [...]" >&2
		return 2
	fi
	varname=${1}
	shift
	while [ $# -gt 0 ] ; do
		if [ -d "${1}" -a -r "${1}"/fonts.dir -a -r "${1}"/fonts.scale ]; then
			eval varvalue='${'${varname}'}'
			if in_fppathvar_p ${varname} "${1}" ; then
				:
			else
				if [ -z "${varvalue}" ]; then
					eval ${varname}='"${1}"'
				else
					eval ${varname}='${'${varname}'}",${1}"'
				fi
			fi
		fi
		shift
	done
	unset varname varvalue
}

fpprepend ()
{
	local varname varvalue

	if [ $# -le 1 -o -z "${1}" ] ; then
		echo "Usage: fpprepend fppathvar directory [...]" >&2
		return 2
	fi
	varname=${1}
	shift
	while [ $# -gt 0 ] ; do
		if [ -d "${1}" -a -r "${1}"/fonts.dir -a -r "${1}"/fonts.scale ]; then
			eval varvalue='${'${varname}'}'
			if in_fppathvar_p ${varname} "${1}" ; then
				:
			else
				if [ -z "${varvalue}" ]; then
					eval ${varname}='"${1}"'
				else
					eval ${varname}='"${1}",${'${varname}'}'
				fi
			fi
		fi
		shift
	done
	unset varname varvalue
}

fpremove ()
{
	local varname

	if [ $# -le 1 -o -z "${1}" ] ; then
		echo "Usage: fpremove fppathvar eRE-directory [...]" >&2
		return 2
	fi
	varname=${1}
	shift
	while [ $# -gt 0 ] ; do
		if in_fppathvar_p ${varname} "${1}" ; then
			# n.b. don't use in_pathvar_p to allow eREs in directory
			eval ${varname}=`eval echo :'$'${varname}: | sed -Ee "s|^${1},||g" -e "s|,${1},|,|g" -e 's|^,+||' -e 's|,+$||'`
		fi
		shift
	done
	unset varname
}

pkgfirst ()
{
	dirremove PATH "$PKG/bin" "$PKG/sbin"
	dirprepend PATH "$PKG/bin"
}

pkglast ()
{
	dirremove PATH "$PKG/bin" "$PKG/sbin"
	dirappend PATH "$PKG/bin"
}

localfirst ()
{
	dirremove PATH "$LOCAL/bin" "$LOCAL/sbin"
	dirprepend PATH "$LOCAL/bin"
}

locallast ()
{
	dirremove PATH "$LOCAL/bin" "$LOCAL/sbin"
	dirappend PATH "$LOCAL/bin"
}

contribfirst ()
{
	dirremove PATH "$CONTRIB/bin" "$CONTRIB/sbin"
	dirprepend PATH "$CONTRIB/bin"
}

contriblast ()
{
	dirremove PATH "$CONTRIB/bin" "$CONTRIB/sbin"
	dirappend PATH "$CONTRIB/bin"
}

slashoptfirst ()
{
	dirremove PATH "$SLASHOPT/bin" "$SLASHOPT/sbin"
	dirprepend PATH "$SLASHOPT/bin"
}

slashoptlast ()
{
	dirremove PATH "$SLASHOPT/bin" "$SLASHOPT/sbin"
	dirappend PATH "$SLASHOPT/bin"
}

gnufirst ()
{
	dirremove PATH "$GNU/bin" "$GNU/sbin"
	dirprepend PATH "$GNU/bin" "$GNU/sbin"
}

gnulast ()
{
	dirremove PATH "$GNU/bin" "$GNU/sbin"
	dirappend PATH "$GNU/bin" "$GNU/sbin"
}

xpgfirst ()
{
	dirremove PATH "/usr/xpg[0-9]/bin" "${PKG}/heirloom-xpg[0-9]/bin"
	dirprepend -e PATH /usr/xpg6/bin /usr/xpg4/bin ${PKG}/heirloom-xpg4/bin
}

xpglast ()
{
	dirremove PATH "/usr/xpg[0-9]/bin" "${PKG}/heirloom-xpg[0-9]/bin"
	dirappend -e PATH /usr/xpg6/bin /usr/xpg4/bin ${PKG}/heirloom-xpg4/bin
}

# every truly POSIX-compliant shell implements the built-in command 'local', but
# then there's ksh (even #93!)
#
# AT&T Ksh is (still, as of ksh93u+) the only shell I know of which has
# functions and which has a 'typset' command but which does not have a 'local'
# command to declare function-scope variables, nor a "built-in" alias for it
# either.  Sigh.
#
# xxx strictly speaking this should probably always be a function that would
# treat any use of options as a usage error
#
# Note that variables made local should always be given a value, or explicitly
# unset, as the default behavior (inheriting the earlier value, or starting
# unset after local) differs amongst shell implementations.

defun_local="local () { :; }"

if is_attksh; then		# if type local >/dev/null 2>&1; then
	# Ksh93:
	#
	#	typeset vname[=value]
	#
	#	When invoked inside a function defined with the
	#	function name syntax, a new instance of the variable
	#	'vname' is created, and the variable's value and type
	#	are restored when the function completes.
	#
	# XXX Sadly in AT&T Ksh this does not actually work for functions
	# defined using the "func() {}" syntax, and that's the only portable way
	# to define a function!  With the standard "fname(){}" syntax variables
	# have a global scope whether you use "typeset" or not.
	#
	# XXX so don't shadow globals in "fname(){}" functions!!!
	#
	# On the other hand in pdksh, "typeset" creates locally-scoped variables
	# regardless of the definition syntax.
	#
	# Note that in AT&T Ksh (and others?) aliases are resolved when a
	# function definition is first read in, so set this early!  Furthermore
	# when a function defined with the "func() {body}" syntax the function
	# name is subject to alias expansion!
	#
	# Also note that functions defined with the "function" keyword have
	# their own trap context.
	#
	# Furthermore $0 is the function name in a function defined by function
	# but the script name in a function defined with ()
	#
	# I used to like AT&T Ksh -- now I'm glad it's only an inspiration...
	#
	function local
	{
		typeset ${1+"$@"}
	}
else
	# for Bourne (heirloom) sh.
	if type local >/dev/null 2>&1; then
		:
	else
		# for Bourne (heirloom) sh, pbosh, etc.(?)
		#
		# This definition of "local" won't actually do anything useful,
		# but it also won't cause a syntax error either.
		#
		# xxx even though this is in an 'if' that souldn't be executed
		# by it, some versions of 'dash', aka "Debian Almquist shell"
		# (which started life as NetBSD sh) will barf and abort just
		# seeing this function definition for 'local' here!!!
		# (dash-0.5.5.1 is OK, dash-0.5.9.1 through 0.5.10.2 are STUPID)
		#
		# even worse it is almost impossible to detect dash
		# programatically.  However luckily we can hide the definition
		# in a variable value....
		#
		eval ${defun_local}
	fi
fi

unset defun_local

# xxx note, after all that about "local", it is not actually used below....

#
# Setup for ls(1) shortcuts.
#
LS_O=
LS_COLOUR=
HAVECOLORLS=false
# XXX perhaps we should just do the following in .profile:
# export CLICOLOR="defined"
if type colorls >/dev/null 2>&1; then
	LS_O=
	LS=`type colorls`
	LS=`expr "$LS" : '^[^/]*\(/[^ )]*\)'`
	HAVECOLORLS=true
	LS_COLOUR="-G"
fi
if type chflags >/dev/null 2>&1; then
	case `uname -s` in
	Darwin*)
		LS_O="O"
		HAVECOLORLS=true	# by coincidence....
		LS_COLOUR="-G"
		LS="/bin/ls"
		;;
	FreeBSD)
		LS_O="o"
		HAVECOLORLS=true	# by coincidence....
		LS_COLOUR="-G"
		LS="/bin/ls"
		;;
	*)
		LS_O="o"	# assume for the BSD best!
		;;
	esac
fi
if [ -z "${LS}" ]; then
	LS=`type ls`
	LS=`expr "$LS" : '^[^/]*\(/[^ )]*\)'`
	if ${LS} --version >/dev/null 2>&1; then
		# likely GNU ls....
		LS_O=""
		HAVECOLORLS=true
		LS_COLOUR="--color=auto"
	elif [ ${LS} = "/usr/bin/ls" ]; then
		# likely SysV-ish or Solaris?
		LS_O=""
		LS_COLOUR=""
	else
		# hmmm.... what could it be?
		LS_O=""
		LS_COLOUR=""
	fi
fi
if [ -n "$TERM" -a "X$TERM" != "Xdumb" ] && $HAVETPUT && $HAVECOLORLS; then
	# xxx colorls(1) is quite "dumb" -- it apparently just uses ANSI color
	# escape sequences directly without consulting $TERM
	if [ "`tput colors`" -gt 0 ]; then
		LS="${LS} ${LS_COLOUR}"
	fi
fi

if type mktable >/dev/null 2>&1; then
	MKTABLE="mktable"
else
	# a little ditty to throw away comment lines....
	# ToDo: allow for changing of the comment character!
	# ToDo: should this remove trailing comments too? (-e '/#.*$//')
	mktable ()
	{
		sed				\
			-e '/^[ 	]*#/d'	\
			-e '/^[ 	]*$/d'	\
		${1+"$@"}
	}
fi

# all machines without 'head' had a shell with functions... well, all that matter
#
if type head >/dev/null 2>&1; then
	: # have the real thing....
else
	head ()
	{
		N=10
		if [ $# -ge 1 ] ; then
			case "$1" in
			-[0-9]*)
				N=`expr x"$1" : '^x-\([0-9]*\)$'`
				shift
				;;
			-n)
				shift
				N=`expr x"$1" : '^x\([0-9]*\)$'`
				shift
				;;
			-*)
				echo "Usage: head [-N] [-n lines] [[file] ...]" 1>&2
				return 2
			esac
		fi
		sed ${N}q ${1+"$@"}

		unset N
	}
fi

: ${CENTRAL_USER:="woods"}
: ${CENTRAL_SERVER:="central.avoncote.ca"} # FQDN for outbound connections
: ${HOME_SERVER:="more"}

#
#	dotfiles2git - meant as an internal helper
#
dotfiles2git ()
{
	( cd $HOME

	git-sccsimport --move-date=2010/11/5T00:00:00 --move-offset=3 --expand-kw --maildomain=robohack.ca --dirs SCCS --git-dir="$HOME/work/home" && cd $HOME/work/home && git push --mirror
	if [ $? -ne 0 ]; then
		echo "dotfiles2git:  check for errors above!" 1>&2
		#
		# Quite possibly some aspect of some change that had
		# already been imported was accidentally changed causing
		# a fork in the change history.  One likely possibility
		# is some aspect of an SCCS file, e.g. a metadata value
		# which appears in the expanded "@(#)" header, was
		# modified, e.g. the module type.
		#
		# In this case there are two choices -- (1) undo the
		# change; or (2) rewrite the git history.
		#
		# For this particular repository the second option is
		# probably OK.  Do the following:
		#
		#   git reset --hard $(git log HEAD^..HEAD | awk '$1 == "commit" {print $2}')
		#   git push --force --mirror
		#
		return 1
	fi
	)
}

archivedotfiles ()
{
	( cd $HOME

	# update the live files on the central server
	#
	rsync -v -lptHS --progress --stats --files-from=$HOME/dotfiles.list $HOME ${CENTRAL_USER}@${CENTRAL_SERVER}:.

	# remove g-files on $CENTRAL_SERVER that have been removed in SCCS
	#
	removed=`vremoved`
	if [ -n "${removed}" ]; then
		ssh ${CENTRAL_USER}@${CENTRAL_SERVER} rm -f ${removed}
	fi
	unset removed

	# update dotfiles.tar.gz
	#
	pax -wzf ${HOME}/dotfiles.tar.gz < ${HOME}/dotfiles.list

	ssh ${CENTRAL_USER}@${CENTRAL_SERVER} rm -f dotfiles.list # is likely unwriteable
	scp ${HOME}/dotfiles.list ${HOME}/dotfiles.tar.gz ${CENTRAL_USER}@${CENTRAL_SERVER}:.

	# publish via HTTP too -- xxx this is sometimes a bit wasteful, but
	# simplest...
	#
	cd $HOME/public_html
	./publish

	)
}

spreaddotfiles ()
{
	dotfiles_hosts="very very-old once"
	dotfiles_hosts="${dotfiles_hosts} nbt"
	dotfiles_hosts="${dotfiles_hosts} xentral"
	dotfiles_hosts="${dotfiles_hosts} b2"	# central gets them from archivedotfiles
	dotfiles_hosts="${dotfiles_hosts} xenful"
	dotfiles_hosts="${dotfiles_hosts} historically" # more is $HOME_SERVER
	dotfiles_hosts="${dotfiles_hosts} xentastic"
	dotfiles_hosts="${dotfiles_hosts} fezzik nbtest nbday nb10"

	case ${HOSTNAME} in
	${HOME_SERVER}*)
		for _sync_host in ${dotfiles_hosts}; do
			echo "spreaddotfiles: pushing to $_sync_host..."
			pushdotfiles -e ssh $_sync_host
		done
		;;
	*)
		echo "spreaddotfiles: not useful when run on a client host!" 1>&2
		return 2
		;;
	esac
}

#
#	publishdotfiles - re-import to git, push, and publish to $CENTRAL_SERVER
#
# meant for incremental updates without creating a new release and can be used
# without SCCS tools (but of course requires git-sccsimport)
#
publishdotfiles ()
{
	case ${HOSTNAME} in
	${CENTRAL_SERVER%%.*}*)	# assume there is only one by this name!
		echo "publishdotfiles: not useful when run on server host!" 1>&2
		return 2
		;;
	${HOME_SERVER}*)
		if [ -z "${HOME}" ]; then
			echo "publishdotfiles: HOME is unset or empty!" 1>&2
			return 2
		fi
		( cd ${HOME}; ${SCCS:-"sccs"} info )

		dotfiles2git || {
			return 1
		}

		# update the archive files on the central server, etc.
		#
		archivedotfiles

		# update dot files on well known hosts
		#
		spreaddotfiles
		;;
	*)
		echo "publishdotfiles: not useful when run on a client host!" 1>&2
		return 2
		;;
	esac
}

#
#	releasedotfiles - publish dotfiles as a release and start a new one
#
releasedotfiles ()
{
	case ${HOSTNAME} in
	${CENTRAL_SERVER})
		echo "releasedotfiles: not useful when run on server host!" >&2
		return 1
		;;
	more*)
		( cd ${HOME}

		vcheck || {
			echo "releasedotfiles: files still being edited!" >&2
			return 1
		}

		vverify || {
			return 1
		}

		# create archives from the "next", i.e. current level, release
		#
		# function is from ~/.shrc
		#
		publishdotfiles

		# update the FTP files for the current release
		#
		# (note I had never put these in /work/release.d, so no need to
		# do so now)
		#
		REL=`vcurrentrel`
		scp dotfiles.list ${CENTRAL_USER}@${CENTRAL_SERVER}:\~ftp/pub/local/dotfiles-v$REL.list
		scp dotfiles.tar.gz ${CENTRAL_USER}@${CENTRAL_SERVER}:\~ftp/pub/local/dotfiles-v$REL.tar.gz
		ssh ${CENTRAL_USER}@${CENTRAL_SERVER} ln -fhs dotfiles-v${REL}.list \~ftp/pub/local/dotfiles.list
		ssh ${CENTRAL_USER}@${CENTRAL_SERVER} ln -fhs dotfiles-v${REL}.tar.gz \~ftp/pub/local/dotfiles.tar.gz
		unset REL

		# finally close off the release and get ready for the next one!
		#
		vnewrel
		if [ $? -ne 0 ]; then
			echo "releasedotfiles:  check for errors above!" >&2
			return 1
		fi
		)
		;;
	*)
		echo "releasedotfiles: this host needs dotfiles updates!" >&2
		return 1
		;;
	esac
}

pushdotfiles ()
{
	# XXX maybe _e_opt should default to "-e rsh" since that's what _rsh does (because RSH)?  or just default to SSH???
	_e_opt=""
	_user=${LOGNAME}
	_copy=false
	_rcp=${RCP:-"scp"}	# xxx currently RCP is a fictional variable
	_rsh=${RSH:-"ssh"}
	_USAGE="Usage: pushdotfiles [-c] [-e TRANSPORT] [-u RUSER] hostname"
	OPTIND="1"
	while getopts "ce:u:" OPTCH
	do
		case ${OPTCH} in
		c)
			_copy=true
			;;
		e)
			_e_opt="-e ${OPTARG}"
			case ${OPTARG} in
			r*)
				_rcp=rcp
				_rsh=rsh
				;;
			s*)
				_rcp=scp
				_rsh=ssh
				;;
			*)
				echo "pushdotfiles: ${OPTARG}: unknown transport" >&2
				return 2
			esac
			;;
		u)
			_user="${OPTARG}"
			;;
		*)
			echo "$_USAGE" >&2
			return 2
			;;
		esac
	done
	shift `expr $OPTIND - 1`

	if [ $# -ne 1 ]; then
		echo "$_USAGE" >&2
		return 2
	fi
	if $_copy; then
		rdirs=`grep '/$' ${HOME}/dotfiles.list`
		if [ $_rcp = "rcp" -a -n "${rdirs}" ]; then
			echo "pushdotfiles: rcp cannot create or copy subdirectories along with files!" >&2
			return 2
		fi
		${_rsh} ${_user}@${1} chmod u+w `cat ${HOME}/dotfiles.list`
		if [ -n "${rdirs}" ]; then
			for _rdir in ${rdirs}; do
				${_rsh} ${_user}@${1} chmod +w ${_rdir}/\*
			done
		fi
		# XXX hmmm.... stale SCCS/p. files might never get removed!
		( cd $HOME
		  ${_rcp} -p -r `cat ${HOME}/dotfiles.list` ${_user}@${1}:
		)
		unset rdirs
	else
		# XXX note that by taking a directory name from a list of files
		# we currently forego the ability to delete files that are no
		# longer in that directory...  Maybe --delete-after would do the
		# trick here, or maybe we should simply exclude SCCS lock files?
		#
		rsync ${_e_opt} -v -lptHS --progress --stats --files-from=${HOME}/dotfiles.list ${HOME} ${_user}@${1}:.
	fi
	( cd $HOME
	  removed=`vremoved`
	  if [ -n "${removed}" ]; then
		${_rsh} ${_user}@${1} rm -f ${removed}
	  fi
	)
	unset _copy _e_opt _rcp _rsh _user _USAGE removed OPTCH
}

syncdotfiles ()
{
	# In theory this could have command-line options to set/override
	# $CENTRAL_*, but that can also be done simply as variable assignments
	if [ -z "${HOME}" ]; then
		echo "syncdotfiles: HOME is unset or empty!" 1>&2
		return 2
	fi
	case ${HOSTNAME} in
	${CENTRAL_SERVER%%.*}*)	# assume there is only one by this name!
		echo "syncdotfiles: not useful when run on server host!" 1>&2
		return 2
		;;
	${HOME_SERVER}*)
		# xxx should check if $HOME is /home/more/$USER?
		echo "syncdotfiles: not useful when run on edit host!" 1>&2
		return 2
		;;
	esac
	rsync -v -lptHS --progress --stats --files-from=:dotfiles.list ${CENTRAL_USER}@${CENTRAL_SERVER}:. $HOME
	if [ -r $HOME/.xinitrc -a ! -x $HOME/.xinitrc ] ; then
		chmod +x $HOME/.xinitrc
	fi
	if ${HAVEEMACS}; then
		if [ $HOME/.emacs.el -nt $HOME/.emacs.elc ]; then
			( cd $HOME && ${MY_EMACS} -batch -q -no-site-file -f batch-byte-compile .emacs.el )
		fi
	fi
}

set_LOCAL_et_al ()
{
	if [ -z "${LOCAL}" ] ; then
		# NOTE:  ${LOCAL} must not contain multiple words!
		if [ -d /local -a ! -L /local ] ; then
			LOCAL="/local"
		elif [ -d /usr/local -a ! -L /usr/local ] ; then
			LOCAL="/usr/local"
		else
			LOCAL="/NO-local-FOUND"
		fi
	fi
	export LOCAL

	if [ -z "${CONTRIB}" ] ; then
		# NOTE:  ${CONTRIB} must not contain multiple words!
		if [ -d /contrib -a ! -L /contrib ] ; then
			CONTRIB="/contrib"
		elif [ -d /usr/contrib -a ! -L /usr/contrib ] ; then
			CONTRIB="/usr/contrib"
		else
			CONTRIB="/NO-contrib-FOUND"
		fi
	fi
	export CONTRIB

	if [ -z "${PKG}" ] ; then
		# NOTE:  ${PKG} must not contain multiple words!
		# XXX some OSX has an un-related /pkg so test /{usr,opt}/pkg first!
		if [ -d /usr/pkg -a ! -L /usr/pkg ] ; then
			PKG="/usr/pkg"
		elif [ -d /opt/pkg -a ! -L /opt/pkg ] ; then
			PKG="/opt/pkg"
		elif [ -d /pkg -a ! -L /pkg ] ; then
			PKG="/pkg"
		else
			PKG="/NO-pkg-FOUND"
		fi
	fi
	export PKG

	if [ -z "${SLASHOPT}" ] ; then
		# NOTE:  ${SLASHOPT} must not contain multiple words!
		if [ -d /opt ] ; then
			SLASHOPT="/opt"
		elif [ -d /usr/opt -a ! -L /usr/opt ] ; then
			SLASHOPT="/usr/opt"
		else
			SLASHOPT="/NO-opt-FOUND"
		fi
	fi
	export SLASHOPT

	if [ -z "${GNU}" ] ; then
		# NOTE:  ${GNU} must not contain multiple words!
		if [ -d /local/gnu -a ! -L /local/gnu -a -d /local/gnu/bin ] ; then
			GNU="/local/gnu"
		elif [ -d /usr/gnu -a -d /usr/gnu/bin ] ; then
			GNU="/usr/gnu"
		elif [ -d /usr/local/gnu -a -d /usr/local/gnu/bin ] ; then
			GNU="/usr/local/gnu"
		elif [ -d /usr/pkg/gnu -a -d /usr/pkg/gnu/bin ] ; then
			GNU="/usr/pkg/gnu"
		elif [ -d /opt/pkg/gnu -a -d /opt/pkg/gnu/bin ] ; then
			GNU="/opt/pkg/gnu"
		elif [ -d /opt/gnu -a -d /opt/gnu/bin ] ; then
			GNU="/opt/gnu"
		else
			GNU="/NO-gnu-FOUND"
		fi
	fi
	export GNU

	if [ -z "${PROJECT}" ] ; then
		PROJECT="SCCS"
	fi
	export PROJECT
}

if [ -z "${WORKPATH}" ] ; then
	WORKPATH=${HOME}/work.d:${HOME}/work
fi
dirappend -e WORKPATH /work/${LOGNAME} ${LOCAL}/work.d/${LOGNAME}
export WORKPATH

ISSUN=false
if [ -x /usr/bin/sun ]; then
	if sun; then
		ISSUN=true
	fi
fi

if $ISSUN; then
	CDP_BSDSRCDIR=/work/src
	CDP_X11SRCDIR=/work/xsrc
	CDP_PKGSRCDIR=/work/pkgsrc
	CDP_PORTSSRCDIR=/work/ports
elif [ `uname -s` = "Darwin" ]; then
	#
	# Modern macOS won't let root create symlinks in / or /usr....
	#
	CDP_BSDSRCDIR=/Volumes/work/src
	CDP_X11SRCDIR=/Volumes/work/xsrc
	CDP_PKGSRCDIR=/Volumes/work/pkgsrc
	CDP_PORTSSRCDIR=/Volumes/work/ports
else
	CDP_BSDSRCDIR=/usr/src
	CDP_X11SRCDIR=/usr/xsrc
	CDP_PKGSRCDIR=/usr/pkgsrc
	CDP_PORTSSRCDIR=/usr/ports
fi

# CDPATH isn't supported in all shells, but it won't hurt....
#
# make sure these directories are fixed in even if they are not
# present at login time.
#
if [ -n "${CDPATH}" ]; then
	OCDPATH=${CDPATH}; export OCDPATH
fi
CDPATH=:${HOME}:${WORKPATH}:${HOME}/src:${HOME}/src/lib:${CDP_BSDSRCDIR}:${CDP_X11SRCDIR}:${CDP_PKGSRCDIR}:${CDP_PORTSSRCDIR}

export CDPATH

if [ -z "${CVSROOT}" ] ; then
	CVSROOT=${LOCAL}/src-CVS ; export CVSROOT
fi

## XXX setting DIFF in the environment screws up too many things...
##
## on older systems GNU Diff is preferred for things that use $DIFF,
## but sometimes it's in ${LOCAL}/bin as just "diff"
##
#if [ -x ${LOCAL}/bin/diff ] ; then
#	DIFF=${LOCAL}/bin/diff
#elif type gdiff >/dev/null 2>&1; then
#	# XXX this isn't always best any more!
#	DIFF="gdiff"
#else
#	# xxx this is probably a no-op...
#	DIFF="diff"
#fi
#export DIFF

if type make >/dev/null 2>&1; then
	if make -v >/dev/null 2>&1; then
		# oops, this system thinks GNU Make is a real Make!
		# Assume there is or will be a "bmake", aka BSD Make
		BMAKE="bmake"
	else
		# Assume for the best...
		BMAKE="make"
	fi
else
	# Hope for the best, eventually...
	BMAKE="make"
fi
export BMAKE

# n.b.:  see also the corresponding elisp functions
#
dfgit2magit ()
{
	if [ -d $HOME/.git ]; then
		echo "dfgit2magit: already in 'magit' mode?" >&2
		return 2
	fi
	if [ ! -d $HOME/.dotfiles-git ]; then
		echo "dfgit2magit: \~/.dotfiles-git missing?" >&2
		return 2
	fi
	mv $HOME/.dotfiles-git $HOME/.git
}

# n.b.:  see also the corresponding elisp functions
#
magit2dfgit ()
{
	if [ -d $HOME/.dotfiles-git ]; then
		echo "magit2dfgit: already in 'dfgit' mode!" >&2
		return 2
	fi
	if [ ! -d $HOME/.git ]; then
		echo "magit2dfgit: \~/.git missing?" >&2
		return 2
	fi
	mv $HOME/.git $HOME/.dotfiles-git
}

dfgit ()
{
	if [ -d $HOME/.git -o ! -d $HOME/.dotfiles-git ]; then
		echo "dfgit: in 'magit' mode!  Run magit2dfgit" >&2
		return 2
	fi
	git --git-dir=$HOME/.dotfiles-git/ ${1+"$@"}
}

lnotes ()
{
	if [ -d $HOME/notes ] ; then
	(
		# in a subshell
		\cd $HOME/notes
		if [ `ls|wc -w` != 0 ] ; then
			echo 'You have notes on: '
			${LS} -dC *[!~]
		fi
	)
	fi
}

#
#	more functions
#

# Csh's repeat last command (from: Robert Elz <kre>)
#
# xxx ksh 93U+ says (with or without "function"):  -ksh: !!: invalid function name
#
# XXX even in an 'if' it complains:  ./.shrc: line 1045: `!!': not a valid identifier
#
#if ! is_attksh; then
#	!! ()
#	{
#		fc -s -1
#	}
#fi

adjlinks ()
{
	# XXX are separate "from" and "to" options better, or should they be
	# just one sed expression, and should it/they be options or args?
	#
	# XXX could/should check if new target exists?

	_USAGE="Usage: adjlinks -f fromRE -t toSTR symlink ..."
	OPTIND="1"
	while getopts "f:t:" OPTCH
	do
		case ${OPTCH} in
		f)
			_from=${OPTARG}
			;;
		t)
			_to=${OPTARG}
			;;
		*)
			echo "$_USAGE" >&2
			return 2
			;;
		esac
	done
	shift `expr $OPTIND - 1`

	if [ -z "${_from}" -o -z "${_to}" -o $# -lt 1 -o -z "$1" ]; then
		echo "$_USAGE" >&2
		return 2
	fi

	for _lnk
	do
		_otarg=`readlink "${_lnk}"`
		if [ $? -eq 0 ]; then
			_ntarg=`echo "${_otarg}" | sed "s|${_from}|${_to}|"`
			if [ "${_otarg}" != "${_ntarg}" ]; then
				rm -f "${_lnk}"
				ln -s "${_ntarg}" "${_lnk}" && echo adjusted: "${_lnk}" '->' "${_otarg}" to: '->' "${_ntarg}"
			fi
		fi
	done
	unset _USAGE _from _to _lnk _otarg _ntarg OPTCH
}

checkptrs ()
{
	if [ $# -ne 1 ]; then
		echo "Usage: checkptrs [ 192.168.1.0 | 1.168.192.in-addr.arpa ]" >&2
		return 2
	fi
	_i=0
	_in_addr_arpa=$1

	case ${_in_addr_arpa} in
	*.in-addr.arpa)
		:
		;;
	*)
		_in_addr_arpa=`echo ${_in_addr_arpa} | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)/\3.\2.\1/'`".in-addr.arpa"
	esac
	echo "checkptrs: checking for all PTRs in: ${_in_addr_arpa}"
	while [ $_i -lt 255 ]; do
		host -a ${_i}.${_in_addr_arpa} 2>/dev/null || true;
		_i=`expr ${_i} + 1`
	done
	unset _i _in_addr_arpa
}

cdpkgwrksrc ()
{
	# XXX don't do anything if not directly in a pacakge dir
	#
	# note:  this can use '${BMAKE} -v WRKSRC' once bmake-20200524 or newer
	# is purvasive....
	#
	cd `${BMAKE} show-var VARNAME=WRKSRC`
	pwd
}

# this name is chosen so as to complement cdpkgwrksrc to facilitate easier
# completion after typing the first three letters
#
cdwrkpkg ()
{
	# XXX don't do anything if not directly in a pacakge dir
	cd `${BMAKE} show-var VARNAME=WRKDIR`
	pwd
}

# Look for all the "CVS/Root" files starting at $PWD and change their contents
# to the given argument.
#
cvsupdateroot ()
{
	find . -path '*/CVS/Root' -exec sh -c "echo \"$1\" > \"{}\" " \;
}

# XXX what good is this again?
#
difforig ()
{
	_DIFFOPTS=""
	if [ $# -le 2 ]; then
		echo "Usage: difforig [-DIFFOPTS] file" >&2
		return 2
	fi
	case "$1" in
	-*)
		_DIFFOPTS=$1
		shift
		;;
	esac
	${DIFF:-diff} $_DIFFOPTS $1.orig $1
	unset _DIFFOPTS
}

filerot ()
{
	:
	# xxx move file to file-, after file- to file-- and so on...
}

get_domainname ()
{
	if [ -r /etc/resolv.conf ] && fgrep domain /etc/resolv.conf >/dev/null 2>&1; then
		#
		# here we use domain, not "search", on purpose so that
		# we will only set DOMAINNAME if that's been done
		# explicitly in resolv.conf -- normally dhclient and
		# such will set "search" from the network DHCP server
		#
		# xxx except of course on MacOS X, aka OSX, aka macOS, aka macos, sigh...
		#
		_D=`sed -n '/^[;#]/d;s/domain[ 	]*/./p' /etc/resolv.conf`
	elif type dnsdomainname >/dev/null 2>&1; then
		# GNU only?
		_D=`dnsdomainname`
	elif type domainname >/dev/null 2>&1; then
		#
		# for laggards like me who use this for DNS too
		#
		_D=`domainname`
	elif expr "${HOSTNAME}" : '[^\.]*\.' >/dev/null 2>&1; then
		_D=`expr "${HOSTNAME}" : '[^\.]*\.\(.*\)$'`
	else
		# these cases for machines without domainname,
		# and a short hostname....
		#
		case "${UUNAME}" in
		weirdo)
			_D=".weird.com"
			;;
		*)
			_D=".UUCP"
			;;
		esac
	fi
	case "${_D}" in
	"(none)"|"")		# "(none") from GNU
		_D=".local"
		;;
	esac
	if expr "${_D}" : '^\.' >/dev/null 2>&1 ; then
		echo ${_D}
	else
		echo .${_D}
	fi
	unset _D
}

get_macos_sdk_path ()
{
	# n.b.:  to see all installed SDKs:
	#
	#	xcodebuild -showsdks
	#
	xcrun -sdk macosx --show-sdk-path
}
SKPREFIX=""
if [ `uname -s` = "Darwin" ]; then
	#
	# this is actually the same as ${SDKROOT} as set by xcrun(1), but for
	# now a different name in the login shell environment is probably
	# apropos...
	#
	SDKPREFIX=`get_macos_sdk_path`
fi
export SDKPREFIX		# xxx hmmm.... should it be exported?

# to deal with shells that may not expand '~' in pathnames
#
# Leverages possible expansion first thus avoiding any obvious fork(s) and
# external command exec(s)
#
get_user_home ()
{
	if [ $# -ne 1 ]; then
		echo "Usage: get_user_home username" >&2
		return 2
	fi
	eval _uhdir=~$1
	case "${_uhdir}" in
	/*)
		echo $_uhdir
		unset _uhdir
		return 0
		;;
	esac
	unset _uhdir
	if type getent >/dev/null 2>&1; then
		getent passwd $1 | awk -F: '{print $6}'
	else
		awk -F: '$1 == "'$1'" {print $6}' < /etc/passwd
	fi
}

# this is a bit like the GNU (err, vim) "xxd -p", but far more portable
#
hexencode ()
{
	hexdump -v -e '1/1 "%02x"'
}

# xxx hmmm... this works!  (assuming we have printf(1), of course)
#
hexdecode ()
{
	sed 's/\([0-9A-Fa-f]\{2\}\)/\\\\\\x\1/g' | xargs printf
}

# xxx this needs an option to specify which column or position the address is in
#
ipaddrsort ()
{
	sed 's/\./ /g' ${1} |
	  sort -b -n -k 1 \
		  -n -k 2 \
		  -n -k 3 \
		  -n -k 4 |
	  sed -E -e 's/([0-9]) /\1./' \
		 -e 's/([0-9]) /\1./' \
		 -e 's/([0-9]) /\1./'
}

imgsize ()
{
	# note modern file(1) can print size too, but not consistently for
	# differnt image types....
	#
	if type exiv2 >/dev/null 2>&1; then
		exiv2 ${1+"$@"} 2>/dev/null | awk '$1 == "Image" && $2 == "size" {print $4 " " $5 " " $6;}'
	else
		# xxx so this only works for JPEGs...
		#
		file ${1+"$@"} | awk '{print $1 " " $(NF-2)}'
	fi
}

kall ()
{
	_SIGOPT=""

	case "$1" in
	-*)
		_SIGOPT=$1
		shift;
		;;
	esac
	kill $_SIGOPT `ps -x | awk '$5 == "'$1'" {print $1}'`
	unset _SIGOPT
}

if type killall >/dev/null 2>&1; then
	: already have a good killall?
else
	killall ()
	{
		if [ $# -eq 1 ]; then
			_signal="-TERM"
			_cmd=$1
		elif [ $# -eq 2 ]; then
			_signal=$1
			_cmd=$2
		fi
		kill $_signal `ps -ax -o pid,ucomm | awk '$2 == "'$_cmd'" { print $1}'`
		unset _signal _cmd
	}
fi

krcmd ()
{
	kill -9 `ps -ax -o uid,pid,ppid,ucomm | awk '$1 == '${id}' && $3 == 1 && $4 == "rcmd" {print $2}'`
}

mailclients ()
{
	awk '$4 == "remote" && $5 == "connection" && $6 == "from" {
		sub(/\[.*$/, "", $7);
		print $7;
	}' ${1+"$@"}
}

mailsizes ()
{
	awk '$5 == "Received" {
		for (fn = 6; fn <= NF; fn++) {
			if (substr($fn, 1, 5) == "SIZE:") {
				size = substr($fn, 6) + 0;
				break;
			}
		}
		print size;
	}' ${1+"$@"}
}

repfirst ()
{
	# replace only the first occurance of $1 found in the input with $2
	#
	# from https://stackoverflow.com/a/33416489

	sed -e "1 s/${1}/${2}/; t" -e "1,// s//${2}/"

	# GNU Sed supports "0,/RE/" as an address range (such that if /RE/
	# matches at the very first line of input then it will already be at the
	# end of its range, whereas "1,/RE/" would still be at the beginning of
	# its range) so GNU Sed can do this with just one expression:
	#
	#	gsed -d "0,/$1/s//$2/"
	#
	# AWK equivalent:
	#
	#	awk "/$1/ && !done { sub(/$1/, \"$2\"); done=1; }; 1;"
}

reverse_word_order ()
{
	_result=""
	for _word in ${1+"$@"}; do
		_result="$_word $_result"
	done
	echo "$_result"
	unset _result _word
}

sedjoinnext ()
{
	# pattern that starts the lines to be appended to their previous lines
	# (note a blank is inserted in place of the newline)
	#
	_start=$1

	sed -e ':a' -e '$!N;s/\n'"${_start}"'/ \1/;ta' -e 'P;D'
	unset _start
}

# Display the opening doc comment in a script file.
#
shelp () {
        _binfile=`which "$1"`

        _hdr=`dd if="$_binfile" count=2 bs=1`
        if [ "$_hdr" = "#!" ]; then
	        sed -rn 's/^### ?//;T;p' "$_binfile"
        fi
	unset _binfile _hdr
}

show_make_var ()
{
	# a more portable version of "make -V \${1}'
	#
	echo "show-var-${1}:;@echo \${$1}" | ${MAKE:-"make"} -f - -f Makefile "show-var-${1}"
}

show_cc_predef ()
{
	${CC:-"cc"} -E -dM -x c /dev/null | sort
}

show_cc_optim ()
{
	# to show optimizer options (and include path, and build info, etc.):
	#
	#OPTIM="-O4"
	#OPTIM="-O3"
	#OPTIM="-O2"
	#OPTIM="-O1"
	#OPTIM="-O0"
	#
	${CC:-"cc"} -v ${OPTIM:-"-O4"} -S -fverbose-asm -o - -x c /dev/null
}

#sedjoinafter ()
#{
#	# pattern that ends the lines to be joined with to their previous lines
#	#
#	end=$1
#
#	sed -e :a -e '/\\$/N; s/\\\n//; ta'
#}

signm ()
{
	grep "^#define[ 	]*SIG.*[ 	]*${1}[ 	]" ${SDKPREFIX}/usr/include/sys/signal.h
}

signo ()
{
	grep -i "^#define[ 	]*.*${1}[ 	]*[0-9]" ${SDKPREFIX}/usr/include/sys/signal.h
}

snmpmiblist ()
{
	( cd $1; echo `awk '{print $1}' .index` | sed 's/ /:/g' )
}

if [ -f /usr/adm/lastlog.ut -a -x /usr/lib/acct/fwtmp ] ; then
	lastlog ()
	{
		YearGrep="grep `date +%Y`"
		if [ $# -eq 1 -a "$1" = "-a" ] ; then
			YearGrep="grep -v 1969"
		elif [ $# -ne 0 ] ; then
			echo 'Usage: lastlog [-a]' >&2
		fi
		/usr/lib/acct/fwtmp < /usr/adm/lastlog.ut | $YearGrep |
			awk '{printf("%-8s %-12s %s\n", $1, $3, substr($0, 56))}'
		unset YearGrep
	}
fi

# these are mostly here (instead of in ~/.profile) for get_newterm()...
#
# N.B.:  note the use of $_ttytype, for $TERMTESTCMD, shared with get_newterm()
# below!
#
HAVETPUT=false
if type tput >/dev/null 2>&1; then
	HAVETPUT=true
	# WARNING: this may only work with a SysV compatible tput.
	# N.B.:  bit-bucket all output -- it is run in ~/.profile for real.
	TERMTESTCMD='tput -T"$_ttytype" init >/dev/null 2>&1'
elif type tset >/dev/null 2>&1; then
	# WARNING:  some tset(1)'s, esp. ULTRIX, fail if stderr is not
	# a tty.  Worse, most will query for a new terminal type if it
	# is unknown!  Note also that '-q' isn't accepted by even
	# recent BSD versions, but '-' is still accepted by the
	# ncurses variant.
	#
	TERMTESTCMD='tset - -I -Q "$_ttytype" </dev/null >/dev/null'
else
	TERMTESTCMD='true'
fi

# this is a function so it can be used interactively after login....
#
# NOTE:  this uses $echo et al, as well as $TERMTESTCMD, none which are
# exported, but they are set by this file, so should be available for all
# interactive shells....
#
# XXX N.B.:  This may not work if functions cannot set global/environment vars,
# though that is only true on ancient non-POSIX compatible shells
#
get_newterm ()
{
	_newttytype=
	_ttytype=$TERM
	TERM=

	while [ "X$TERM" != "X$_ttytype" ] ; do
		$echo $n "Please enter your terminal type [$_ttytype]: $c"
		read _newttytype
		if [ -n "$_newttytype" ] ; then
			_ttytype=$_newttytype
		fi
		if [ "$_ttytype" = "dumb" ] ; then
			# n.b.:  we must guarantee a way out of this loop!
			#
			# (that's because tput(1) hates dumb terminals, i.e. it
			# exits non-zero if the terminal doesn't support the
			# "init" attribute)
			TERM="dumb"
			break
		fi
		if eval $TERMTESTCMD ; then
			TERM=$_ttytype
		else
			echo "Sorry, I don't know that terminal type."
			echo "Use 'dumb' if you are stuck."
		fi
	done
	unset _newttytype _ttytype
	export TERM
}

if [ -n "$DISPLAY" ]; then
	onx11server ()
	{
		_RDISPLAY=${REMOTE_DISPLAY:-${DISPLAY}}
		_REMSHELL=${RSH:-rsh}
		# note: $argv0 will have been set by .xinitrc, but....
		_USAGE="onx11server: Usage: onx11server -[fnSY] [-D REMOTE_DISPLAY] -X X11SERVERNAME command [args ...]'"
		_nullopt=""
		_tunopt=""
		_X11server=""
		OPTIND="1"
		while getopts "fnD:SX:Y" OPTCH
		do
			case ${OPTCH} in
			n|f)
				# The OpenSSH ssh(1) manual says:
				#
				#    The recommended way to start X11 programs
				#    at a remote site is with something like:
				#    "ssh -f host xterm".
				#
				# for ssh '-f' puts itself into the background
				# and implies '-n'
				#
				_nullopt="-${OPTCH}"
				;;
			D)
				_RDISPLAY=${OPTARG}
				;;
			S)
				_REMSHELL=${SSH:-ssh}
				;;
			X)
				_X11server=${OPTARG}
				;;
			Y)
				# XXX n.b. try adding -Snone "because session
				# multiplexing doesn't work very well with X
				# forwarding"
				#
				_tunopt="-CY"
				unset _RDISPLAY
				;;
			*)
				echo "$_USAGE" >&2
				return 2
				;;
			esac
		done
		shift `expr $OPTIND - 1`

		# XXX this isn't really useful to catch quoting problems as
		# there will almost always be another parameter, the command,
		# which will end up as the X11SERVERNAME when quoting isn't
		# used....
		#
		if [ -z "${_X11server}" ]; then
			echo "onx11server: -X X11SERVERNAME not set!" >&2
			echo "$_USAGE" >&2
			return 2
		fi

		# Note:  the remote shell is asked to explicitly source
		# ~/.profile on the remote server so as to set up $PATH and
		# other things since most X11 apps we start remotely are
		# effectively interactive environments, especially if they are
		# editors or media viewers or such.  Besides this is the easiest
		# and most reliable way to find the remote server's $X11PATH.
		# Note though that the remote shell will not be an interactive
		# shell, nor a login shell.
		#
		echo "onx11server: starting $_REMSHELL $_nullopt $_tunopt $_X11server ${LANG:+LANG=${LANG}\; export LANG\;} ${LC_ALL:+LC_ALL=${LC_ALL}\; export LC_ALL\;} ${LC_CTYPE:+LC_CTYPE=${LC_CTYPE}\; export LC_CTYPE\;}. ./.profile\; ${_RDISPLAY:+DISPLAY=${_RDISPLAY}\; export DISPLAY\;} ${1+\"$@\"}"

		# Note:  The command is not run in the background here -- let
		# the caller do that (unfortunately we must have a shell waiting
		# for the rsh/ssh to keep the connection open so that the remote
		# process will continue running anyway).
		#
		$_REMSHELL $_nullopt $_tunopt $_X11server ${LANG:+LANG=${LANG}"; export LANG;"} ${LC_ALL:+LC_ALL=${LC_ALL}"; export LC_ALL;"} ${LC_CTYPE:+LC_CTYPE=${LC_CTYPE}"; export LC_CTYPE;"} . ./.profile\; ${_RDISPLAY:+DISPLAY=${_RDISPLAY}"; export DISPLAY;"} ${1+"$@"}

		unset _RDISPLAY _REMSHELL _USAGE _nullopt _tunopt _X11server OPTCH
	}
	lxterm ()
	{
		if [ $# -ne 0 ]; then
			_ARGS=${1+"$@"}
		else
			_ARGS="-e login -pf ${USER:-${LOGNAME}}"
		fi
		# alternatively:  unset LC_ALL; eval export `locale` ; unset LC_ALL
		LANG=C LC_ALL=C eval xterm $XTERM_OPTS -T $HOSTNAME $_ARGS &
		unset _ARGS
	}
	luxterm ()
	{
		if [ $# -ne 0 ]; then
			_ARGS=${1+"$@"}
		else
			_ARGS="-e login -pf ${USER:-${LOGNAME}}"
		fi
		eval uxterm $XTERM_OPTS -T $HOSTNAME $_ARGS &
		unset _ARGS
	}
	rxauth ()
	{
		# xxx this is a bit ugly -- for ssh you have to pass the -S after the rhost
		_rhost=$1
		shift
		_RDISP=${REMOTE_DISPLAY:-${DISPLAY}}

		xauth nextract - ${_RDISP} | onx11server -X $_rhost ${1+"$@"} 'xauth nmerge -'
		unset _rhost _RDISP
	}
	rxterm ()
	{
		_rhost=$1
		shift
		if [ $# -ne 0 ]; then
			_ARGS=${1+"$@"}
		else
			_ARGS="-e login -pf ${USER:-${LOGNAME}}"
		fi

		onx11server -X "${_rhost}" unset LC_ALL\; eval export `locale`\; unset LC_ALL\; xterm $XTERM_OPTS -T rsh:$_rhost $_ARGS < /dev/null &
		unset _rhost _ARGS
	}
	ruxterm ()
	{
		_rhost=$1
		shift
		if [ $# -ne 0 ]; then
			_ARGS=${1+"$@"}
		else
			_ARGS="-e login -pf ${USER:-${LOGNAME}}"
		fi
		onx11server -X "${_rhost}" uxterm $XTERM_OPTS -T rsh:$_rhost $_ARGS < /dev/null &
		unset _rhost _ARGS
	}
fi

do_first_time ()
{
	# TODO:  do something with msgs(1) if needed....
	# TODO:  should use $HAVEFORTUNE and $FORTUNE
	if [ -x /usr/games/fortune ] ; then
		echo ""
		/usr/games/fortune
	elif [ -x ${LOCAL}/games/fortune ] ; then
		echo ""
		${LOCAL}/games/fortune
	fi
	if [ -r calendar -o -r diary -o -r .month ] ; then
		echo ""
		echo "Today's Events:"
		if ${HAVEMONTH} && [ -r .month ] ; then
			month -B
			#		monthd -i5
		fi
		if ${HAVECALENDAR} ; then
			if [ -r calendar ] ; then
				calendar -l 2 -w 4
			elif [ -r diary ] ; then
				#
				# uses cpp, which gets confused with some
				# comments....  and unfortunately won't accept
				# '-f -', nor will it read from /dev/stdin or
				# /fdesc/stdin...  grrr....
				#
				calendar -l 2 -w 4 -f diary 2>/dev/null
			fi
		fi
	fi
	if [ -r ${HOME}/.trninit${TERM} ] ; then
		TRNINIT=${HOME}/.trninit${TERM} ; export TRNINIT
	fi
	lnotes
}

if ${ISATTY}; then
	#TTYN=`basename $TTY`
	# better to see the "pty/" prefix than just the number?
	TTYN=`expr "$TTY" : "/dev/\(.*\)"`
else
	TTYN="not-a-tty"
fi

if type ismpx >/dev/null 2>&1; then
	: might just be running layers
else
	# otherwise it's just not possible....
	ismpx ()
	{
		if [ X$1 != X"-s" ]; then
			echo "no"
		fi
		false
	}
fi

if ismpx -s || [ "$TERM" = "dmd-myx" ] ; then
	if [ "${LEV:-0}" -eq 0 ] ; then
		# in xterms, we are (normally, supposed to be) a login
		# shell, but not in layers
		do_first_time
	fi
	if [ -z "${D_PS1}" ]; then
		PS1="${PS1}${UUNAME}"
	fi
	MYXCLR_L="`myxban -l`"
	MYXCLR_C="`myxban -c`"
	MYXCLR_R="`myxban -r`"
	MYXCLR=${MYXCLR_L}${MYXCLR_C}${MYXCLR_R}
	MYXBAN_L='${BANNER_PWD}'

	clearban ()
	{
		$echo $n "${MYXCLR}$c"
		WBANNER="${OWBANNER}"
		setban
	}

	setban ()
	{
		if [ $# -ge 1 ]; then
			OWBANNER=${WBANNER}
			# no trailing space -- usually just used to
			# set alternate shell name
			WBANNER="${1+\"$@\"}"
		fi
		if [ -z "$BANNER_PWD" ]; then
			BANNER_PWD=`pwd | sed -e "s;^$HOME;~;" -e 's;^.*/work.d/;work.d/;' -e 's;.*/home.*/\([^/][^/]*\)$;\~\1;'`
		fi
		$echo $n "${MYXCLR}$c"
		eval myxban -l "\"$MYXBAN_L\""
		myxban -c "${WBANNER:-`basename ${SHELL}`}"
		eval myxban -r "\"$MYXBAN_R\""
		unset BANNER_PWD
	}

	psm ()
	{
		ps -ft `tty | sed 's|/dev/xt|xt/|'`
	}

fi
# else
case "$TERM" in
*xterm*)
	if [ -z "${D_PS1}" ]; then
		PS1="${PS1}${UUNAME}"
	fi

	clearban ()
	{
		WBANNER="${OWBANNER}"
		setban
	}
	# for debugging, i.e. to show clearban is indeed being called...
	#
	#if type typeset >/dev/null 2>&1; then
	#	typeset -ft clearban
	#fi

	setban ()
	{
		if [ $# -ge 1 ]; then
			OWBANNER=${WBANNER}
			# no trailing space -- usually just used to
			# set alternate shell name
			WBANNER="${1+\"$@\"}"
		fi
		if [ -z "$BANNER_PWD" ]; then
			# only if needed (it's expensive), would be done by 'cd'
			# if possible
			#
			# XXX ToDo:  should extract the version in .shpwd as a
			# separate function
			BANNER_PWD=`pwd | sed -e "s;^$HOME;~;" -e 's;^.*/work.d/;work.d/;' -e 's;.*/home.*/\([^/][^/]*\)$;\~\1;'`
		fi
		if is_attksh; then
			# XXX ksh93 massively messes up parsing backticks in a
			# variable expansion -- it never finds the second one!!!
			if [ "$user" = "$LOGNAME" ]; then
				TBANNER="${WBANNER:-$(basename ${SHELL})}://$UUNAME/$BANNER_PWD | $user[$LEV]:$TTYN"
			else
				TBANNER="${WBANNER:-$(basename ${SHELL})}://$UUNAME/$BANNER_PWD | $user:$group($LOGNAME)[$LEV]:$TTYN"
			fi
		else
			if [ "$user" = "$LOGNAME" ]; then
				TBANNER="${WBANNER:-`basename ${SHELL}`}://$UUNAME/$BANNER_PWD | $user[$LEV]:$TTYN"
			else
				TBANNER="${WBANNER:-`basename ${SHELL}`}://$UUNAME/$BANNER_PWD | $user:$group($LOGNAME)[$LEV]:$TTYN"
			fi
		fi
		if type printf >/dev/null 2>&1; then
			printf "\033]0;%s\007" "${TBANNER}"
		else
			$echo $n "\033]0;${TBANNER}\007$c"
		fi

		unset BANNER_PWD
	}
	;;
*)
	# assume there's only a plain terminal with no banner line...
	#
	if [ -z "${D_PS1}" ]; then
		if [ "$user" != "$LOGNAME" ] ; then
			PS1="${PS1}$TTYN:$user($LOGNAME)@$UUNAME)"
		else
			PS1="${PS1}$TTYN:$LOGNAME@$UUNAME"
		fi
	fi
	;;
esac

if type setban >/dev/null 2>&1; then

	setban

	# XXX most versions of SysV sh always run builtins before functions
	# though Heirloom Sh does not.
	#
	# xxx this may be redefined immediately if ~/.shpwd is readable, or
	# later for certain shells if their custom ~/.${SHELL}pwd is readable
	#
	cd ()
	{
		# note this has to support various ksh without chdir and/or
		# weird "builtin" as $ENV won't be sourced until after .profile
		# is finished, and we try "cd" at the end of this file...
		#
		if type chdir >/dev/null 2>&1; then
			chdir ${1+"$@"}
		elif type command >/dev/null 2>&1; then
			command cd ${1+"$@"}
		else
			builtin cd ${1+"$@"}
		fi
		PWD=`pwd`
		BANNER_PWD=${PWD}
		setban
	}

	if [ -r $HOME/.shpwd ] ; then
		. $HOME/.shpwd
	fi

	#
	# XXX ToDo:  re-factor into a function which defines functions....
	#
	# I.e. write the function definition into a variable value, then eval
	# the variable to define the function.  (See experiments/tfunc.sh)
	#

	# xxx we don't try to preserve any original traps for 1 2 3 15....

	if [ "$VISUAL" = "emacsclient" -a -z "$DISPLAY" ] ; then
		EMACS=`type emacs`
		EMACS=`expr "${EMACS}" : '^[^/]*\(/[^ )]*\)'`
		# this sort of assumes TERM=dmd or similar
		emacs ()
		{
			msg=n
			if mesg >/dev/null 2>&1 ; then msg=y; fi
			trap "trap 1 2 3 15; clearban; mesg $msg || true" 1 2 3 15
			OWBANNER=${WBANNER}
			WBANNER="GNU Emacs @ $UUNAME"
			setban
			mesg n || true
			$EMACS ${1+"$@"}
			clearban
			mesg $msg || true
			trap 1 2 3 15
		}
	fi

	if expr "`type cu 2>/dev/null`" : '.* is .*/cu)*$' >/dev/null 2>&1 ; then
		CU=`type cu`
		CU=`expr "$CU" : '^[^/]*\(/[^ )]*\)'`
		cu ()
		{
			msg=n
			if mesg >/dev/null 2>&1 ; then msg=y; fi
			if [ "$TERM" = "dmd" -o "$TERM" = "dmd-myx" ] ; then
				trap "trap 1 2 3 15; mkmenu -; clearban; mesg $msg || true" 1 2 3 15
				myxsize -s
			else
				trap "trap 1 2 3 15; clearban; mesg $msg || true" 1 2 3 15
			fi
			OWBANNER=${WBANNER}
			WBANNER="cu ${1+\"$@\"}"
			setban
			mesg n || true
			$CU ${1+"$@"}
			clearban
			mesg $msg || true
			trap 1 2 3 15
		}
	fi

	if expr "`type ckermit 2>/dev/null`" : '.* is .*/ckermit)*$' >/dev/null 2>&1 ; then
		CKERMIT=`type ckermit`
		CKERMIT=`expr "$CKERMIT" : '^[^/]*\(/[^ )]*\)'`
		ckermit ()
		{
			msg=n
			if mesg >/dev/null 2>&1 ; then msg=y; fi
			if [ "$TERM" = "dmd" -o "$TERM" = "dmd-myx" ] ; then
				trap "trap 1 2 3 15; mkmenu -; clearban; mesg $msg || true" 1 2 3 15
				myxsize -s
			else
				trap "trap 1 2 3 15; clearban; mesg $msg || true" 1 2 3 15
			fi
			OWBANNER=${WBANNER}
			WBANNER="C-Kermit ${1+\"$@\"}"
			setban
			mesg n || true
			$CKERMIT ${1+"$@"}
			clearban
			mesg $msg || true
			trap 1 2 3 15
		}
	fi

	if expr "`type slogin 2>/dev/null`" : '.* is .*/slogin)*$' >/dev/null 2>&1 ; then
		SLOGIN=`type slogin`
		SLOGIN=`expr "$SLOGIN" : '^[^/]*\(/[^ )]*\)'`
		slogin ()
		{
			msg=n
			if mesg >/dev/null 2>&1 ; then msg=y; fi
			trap "trap 1 2 3 15; clearban; mesg $msg || true" 1 2 3 15
			OWBANNER=${WBANNER}
			WBANNER="slogin ${1+\"$@\"}"
			setban
			mesg n || true
			$SLOGIN ${1+"$@"}
			clearban
			mesg $msg || true
			trap 1 2 3 15
		}
	fi

	if expr "`type rlogin 2>/dev/null`" : '.* is .*/rlogin)*$' >/dev/null 2>&1 ; then
		RLOGIN=`type rlogin`
		RLOGIN=`expr "$RLOGIN" : '^[^/]*\(/[^ )]*\)'`
		rlogin ()
		{
			msg=n
			if mesg >/dev/null 2>&1 ; then msg=y; fi
			trap "trap 1 2 3 15; clearban; mesg $msg || true" 1 2 3 15
			OWBANNER=${WBANNER}
			WBANNER="rlogin ${1+\"$@\"}"
			setban
			mesg n || true
			$RLOGIN ${1+"$@"}
			clearban
			mesg $msg || true
			trap 1 2 3 15
		}
	fi

	if expr "`type telnet 2>/dev/null`" : '.* is .*/telnet)*$' >/dev/null 2>&1 ; then
		TELNET=`type telnet`
		TELNET=`expr "$TELNET" : '^[^/]*\(/[^ )]*\)'`
		telnet ()
		{
			msg=n
			if mesg >/dev/null 2>&1 ; then msg=y; fi
			if [ "$TERM" = "dmd" -o "$TERM" = "dmd-myx" ] ; then
				trap "trap 1 2 3 15; mkmenu -; clearban; mesg $msg || true" 1 2 3 15
				myxsize -s
			else
				trap "trap 1 2 3 15; clearban; mesg $msg || true" 1 2 3 15
			fi
			OWBANNER=${WBANNER}
			WBANNER="telnet ${1+\"$@\"}"
			setban
			mesg n || true
			$TELNET ${1+"$@"}
			clearban
			mesg $msg || true
			trap 1 2 3 15
		}
	fi

	if expr "`type mush 2>/dev/null`" : '.* is .*/mush)*$' >/dev/null 2>&1 ; then
		TELNET=`type mush`
		TELNET=`expr "$MUSH" : '^[^/]*\(/[^ )]*\)'`
		mushC ()
		{
			msg=n
			if mesg >/dev/null 2>&1 ; then msg=y; fi
			trap "trap 1 2 3 15; clearban; mesg $msg || true" 1 2 3 15
			OWBANNER=${WBANNER}
			WBANNER="MUSH ${1+\"$@\"}"
			setban
			mesg n || true
			$MUSH -C ${1+"$@"}
			clearban
			mesg $msg || true
			trap 1 2 3 15
		}
	fi

	if expr "`type nethack 2>/dev/null`" : '.* is .*/nethack)*$' >/dev/null 2>&1 ; then
		NETHACK=`type nethack`
		NETHACK=`expr "$NETHACK" : '^[^/]*\(/[^ )]*\))'`
		nethack ()
		{
			msg=n
			if mesg >/dev/null 2>&1 ; then msg=y; fi
			if [ "$TERM" = "dmd" -o "$TERM" = "dmd-myx" ] ; then
				trap "trap 1 2 3 15; loadfont thin.9x14; clearban; mesg $msg || true" 1 2 3 15
				loadfont rogue.9x18
			else
				trap "trap 1 2 3 15; clearban; mesg $msg || true" 1 2 3 15
			fi
			OWBANNER=${WBANNER}
			WBANNER="NetHack"
			setban
			mesg n || true
			$NETHACK ${1+"$@"}
			clearban
			mesg $msg || true
			trap 1 2 3 15
		}
	fi

	if [ -x /usr/5bin/su ] ; then
		SU=/usr/5bin/su
	elif [ -x /usr/bin/su ] ; then
		SU=/usr/bin/su
	elif [ -x /bin/su ] ; then
		SU=/bin/su
	else
		SU=`type su`
		SU=`expr "$SU" : '^[^/]*\(/[^ )]*\)'`
	fi
	su ()
	{
		msg=n
		if mesg >/dev/null 2>&1 ; then msg=y; fi
		trap "trap 1 2 3 15; clearban; mesg $msg || true" 1 2 3 15
		# n.b.:  see also the banner setting in "if [ "$uid" -eq 0 ]" below
		OWBANNER=${WBANNER}
		WBANNER="SU ${*-root} `basename ${SHELL}`"
		setban
		mesg n || true
		$SU ${1+"$@"}
		clearban
		mesg $msg || true
		trap 1 2 3 15
	}

fi

# Transform id(1)'s output into useful shell variable assignments
#
# UGLY, but it works
#
# NOTE:  there's a trick in here -- if there's no group name for your GID then
# the final expression parameter won't do anything.  However since the extra
# "groups=..." stuff (which may have had more word-surrounded parens) has
# already been trimmed off the end the only thing that'll be left is the
# original "gid=20" string, so $group simply won't be set, so afterward it is
# set to $gid instead.
#
eval "`id | sed -e 's/ groups=.*$//' \
		 -e 's/(\([^) ]*\)) / user=\1 /' \
		 -e 's/(\([^) ]*\))/ group=\1/'`"
: ${group:=${gid}}

if [ "$uid" -eq 0 ] ; then
	#
	# we always want persistent (and shared) history for 'su'
	#
	ROOT_HOME=`get_user_home root`
	if [ -n "$HISTFILE" ]; then
		HISTFILE="${ROOT_HOME}/`basename $HISTFILE`"
	else
		# xxx should this set per-KSHTYPE files as ~/.kshlogin does?
		HISTFILE="${ROOT_HOME}/.sh_history"
	fi
	if [ ! -f $HISTFILE ]; then
		touch $HISTFILE
	fi
	# see also ~/.kshlogin (et al)
	HISTSIZE=2000

	PRE_SU_PATH=$PATH

	# XXX this is for older macos systems (e.g. 10.13.6) with Joyent
	# packages where the 'nbase' build of awk version 20121220 dumps core on
	# the script in removedups!  (same version as /opt/pkg/bin/nawk works!)
	#
	dirremove PATH /opt/pkg/nbase/bin

	removedups PATH

	# got to get rid of lone ":" or any "." in PATH
	PATH=`echo $PATH | sed -e 's/::/:/g'	\
				-e 's/^://'	\
				-e 's/:$//'	\
				-e 's/^\.://'	\
				-e 's/:\.://g'	\
				-e 's/:\.$//'`
	if [ -n "$SU_FROM" ]; then
		# xxx this is a trick, and only necessary on machines
		# without my fixed "su" -- we reset LOGNAME in case
		# this was a proper and secure 'su' (i.e. one that
		# reset the environment, especially and including
		# $HOME, etc., including of course $LOGNAME).  This
		# does two things.  First, and most important, though
		# most dangerous, it tricks emacs, for now, into
		# finding ~$LOGNAME/.emacs[.elc].  Second it
		# simplifies the next PATH cleanup step....
		#
		# we set USER to "root" explicitly even if the user
		# did not use "su -l" as they probably should have...
		#
		LOGNAME=$SU_FROM
		export LOGNAME
		USER="root"
		export USER
	fi
	if [ -n "$SUDO_USER" ]; then
		# xxx this is a similar trick for OSX and Linux braindamage
		LOGNAME=$SUDO_USER
		export LOGNAME
		USER="root"
		export USER
	fi
	# also get rid of the login user's ~/{usr/bin,bin,go/bin} because they
	# are usually first, and they usually contains personal hacks or test
	# programs that are probably not safe to use as root, and (if this is
	# not ~$SU_FROM/.kshrc then ~$SU_FROM/bin may also contain trojans or
	# worse)
	#
	# n.b.:  this only works properly if the shell can expand "~user",
	# though if eventually neede it could be changed to use the
	# get_user_home function above....
	#
	LOGNAMEPATH=`eval echo ~$LOGNAME/usr/bin`
	dirremove PATH ${LOGNAMEPATH}
	LOGNAMEPATH=`eval echo ~$LOGNAME/bin`
	dirremove PATH ${LOGNAMEPATH}
	LOGNAMEPATH=`eval echo ~$LOGNAME/go/bin`
	dirremove PATH ${LOGNAMEPATH}

	unset LOGNAMEPATH

	SU_POST_CLEAN_PATH=$PATH

	# must have X11BIN before openwin if newer X on system....
	dirappend -e PATH /usr/lbin /usr/ucb ${X11BIN}

	if [ -z "$UUNAME" ]; then
		# xxx don't bother with trying the real uuname -l
		UUNAME=`hostname`
		export UUNAME
	fi
	if [ -z "$HOSTNAME" ]; then
		HOSTNAME=`hostname`
		export HOSTNAME
	fi
	case "${HOSTNAME}" in
	*.local)
		DOMAINNAME=".local"
		;;
	esac
	if [ -z "$DOMAINNAME" ]; then
		DOMAINNAME=`get_domainname`
		export DOMAINNAME
	fi

	if $ISSUN ; then
		PATH=`echo $PATH | sed 's/^\/bin://'`
		if [ `uname -r | sed 's/^\([0-9]*\).*$/\1/'` -lt 5 ] ; then
			if [ "X$LOGNAME" != "Xroot" ] ; then
				dirprepend -e PATH /usr/5bin
			else
				dirappend -e PATH /usr/5bin
			fi
		else
			dirprepend -e PATH /opt/SUNWspro/bin
		fi
		# XXX FIXME: should use OPENWINHOME ???
		# XXX FIXME: should only do this if DISPLAY set???
		dirappend -e PATH /usr/openwin/bin /usr/openwin/demo
		dirappend -e MANPATH /usr/openwin/share/man
	fi
	if [ ! -d /usr/sbin ] ; then
		dirprepend -e PATH /usr/etc	# only old BSDs
	fi
	if [ ! -d /sbin -a ! -d /usr/etc ] ; then
		dirprepend -e PATH /etc		# only really old systems...
		dirappend -e PATH /usr/lib	# ditto
	fi
	dirprepend -e PATH /sbin /usr/sbin $LOCAL/sbin $PKG/sbin $CONTRIB/sbin $SLASHOPT/sbin $GNU/sbin
	if [ -n "${UUCPSPOOLDIR}" ]; then
		dirappend -e PATH /usr/libexec/uucp /usr/lib/uucp
	fi
	dirappend -e PATH $ROOT_HOME/bin

	if [ -z "$UUNAME" ]; then
		if type uuname >/dev/null 2>&1 ; then
			UUNAME=`uuname -l`
		else
			UUNAME=`hostname`
		fi
		export UUNAME
	fi

	set_LOCAL_et_al

	if ismpx -s || [ "$TERM" = "dmd-myx" ] ; then
		# xxx should do this in setban...
		MYXBAN_R='$user:$group($LOGNAME)@$UUNAME[$LEV]:$TTYN'
		dirappend -e PATH $DMD/bin $DMDSGS/bin/3b5 $DMD/local/bin
	fi

	: ${PSc:="#"}
	MAILPATH=${MAILDIR}/${LOGNAME}:${MAILDOR}/root:${MAILDIR}/uucp:${MAILDIR}/usenet
	# XXX assume any emacsclient will try to use the user's server process
	case "$VISUAL" in
	*emacsclient*)
		VISUAL="${MY_EMACS} -nw"
		export VISUAL
		;;
	esac
	case "$EDITOR" in
	*emacsclient*)
		EDITOR="${MY_EMACS} -nw"
		export EDITOR
		;;
	esac
	# just make damn sure PAGER is set...
	if type less >/dev/null 2>&1; then
		PAGER="less"
		LESS="-M"
		export LESS
	elif [ -x /usr/xpg4/bin/more ] ; then
		# SunOS-5's, at least, has the 'G' command!
		PAGER="/usr/xpg4/bin/more"
		# use '-s' as it can't be turned on later during runtime
		MORE="-s"
		export MORE
	elif [ "${PAGER##*/}" = "more" ] ; then
		PAGER="more"
		# use '-s' as it can't be turned on later during runtime
		MORE="-sw"
		export MORE
	else
		# meow
		PAGER="cat"
	fi
	export PAGER
	if [ "$PAGER" = "less" ]; then
		MANPAGER="$PAGER -Rsi"
		export MANPAGER
	fi

	if [ -n "$DISPLAY" -a -z "$XAUTHORITY" ]; then
		#
		# XXX if root is using this .kshrc then perhaps we
		# should try copying the "xauth" information for the
		# current display to $HOME/.Xauthority instead of just
		# pointing at it...  but why bother???
		#
		# n.b.:  this only works properly if the shell can expand
		# "~user"
		#
		XAUTHORITY=`eval echo ~${SU_FROM}/.Xauthority`
		export XAUTHORITY
	fi

	unset -f krcmd || true
	krcmd ()
	{
		# WARNING: this version kills everyone's rcmd procs!
		kill -9 `ps -axlc | awk '$3 == 1 && $13 == "rcmd" {print $2}'`
	}

	# until there's an "rm" subcommand in blocklistctl(8) itself!
	#
	# N.B.:  this doesn't remove the entry from the database, so a reboot
	# will re-instate the filter rule!
	#
	blocklistctl_rm ()
	{
		_address=$1

		if [ $# -le 1 -o -z "${1}" ] ; then
			echo "Usage: blocklistctl_rm address" >&2
			return 2
		fi

		# /libexec/blocklistd-helper action rulename protocol address mask [port] [id]
		/libexec/blocklistd-helper rem blocklistd tcp ${_address} 32

		unset _address
	}

	cd	# I don't know if this is right, or not, but let's try for now...

	# n.b.:  see also the banner setting in "if [ "$uid" -eq 0 ]" below
	OWBANNER=${WBANNER}
	WBANNER="SU root `basename ${SHELL}`"
	setban
elif [ "$user" != "$LOGNAME" ] ; then
	if ismpx -s || [ "$TERM" = "dmd-myx" ] ; then
		# xxx should do this in setban...
		MYXBAN_R='$user:$group($LOGNAME)@$UUNAME[$LEV]:$TTYN'
	fi
	: ${PSc:='$'}
else
	if ismpx -s || [ "$TERM" = "dmd-myx" ] ; then
		# xxx should do this in setban...
		MYXBAN_R='$LOGNAME{$group}@$UUNAME[$LEV]:$TTYN'
	fi
	: ${PSc:='$'}
fi
if [ -z "${D_PS1}" ]; then
	PS1="${PS1} ${PSc} "
fi

if [ "$user" = usenet -o "$group" = news ] ; then
	dirprepend -e PATH $LOCAL/lib/newsbin $LOCAL/lib/newsbin/maint $LOCAL/lib/newsbin/input
fi
if [ "$user" = cyrus -o "$group" = cyrus ] ; then
	dirprepend -e PATH $LOCAL/cyrus/bin $PKG/cyrus/bin $SLASHOPT/cyrus/bin $CONTRIB/cyrus/bin
fi

D_PS1="done"

#
# now some helpful functions
#

if [ -f /usr/share/misc/na.phone ]; then
	areacode ()
	{
		grep ${1+"$@"} /usr/share/misc/*.phone
	}
fi

errno ()
{
	grep "^#define[ 	]*[A-Z][A-Z]*[ 	]*$1[ 	]" ${SDKPREFIX}/usr/include/sys/errno.h
}

file2imgsz ()
{
	# file(1), as of 5.39 at least, displays the pixel size of a JPG in a
	# "field" matching "[0-9]*x[0-9]*," unless the "field" starts with the
	# word "density".... (fields are (un)officially comma separated, but we
	# can split using the normal AWK FS and stilll easily find the match)
	#
	awk '{file=$1; for (f=1; f<NF; f++) {if ($(f-1) != "density" && $f ~ /[0-9]*x[0-9]*,/) {print file $f}}}'
}

hex2d ()
{
	# N.B.:  this is only usable if the shell supports arithmetic expansions
	#
	# xxx NetBSD ksh (and most/all other pdksh derivatives) don't seem to
	# understand octal.  NetBSD sh does understand strict octal (with a
	# leading 0), but ksh93 does a (not-so-)"smart" conversion and if any
	# digits are >7 it will treat numbers with a leading zero as if they are
	# decimal!  (All require a leading "0x" to recognize hex -- should we
	# prepend it if missing?  Probably not.)
	#
	echo "$(($@))"
}

maillog ()
{
	# Warning:  less (at least up to v. 394) has a limitation of about 95
	# chars (or perhaps UNGOT_SIZE, 100) to the length of the '-p'
	# parameter.  (xxx otherwise I would also include words like "core",
	# "signal", and "trace")
	#
	# N.B.:  --follow-name was introduced in less-416, which was released
	# between the imports of less-394 and less-444, before NetBSD-4.0 and
	# NetBSD-6.0 respectively; so it's been in since 6.0.
	#
	$PAGER --follow-name -enM -p ": \[[0-9]+\] (\[.+\] )?((remote[A-Z ]*:)|remote ..LO: (rejected: inv[^:]*:|refusing) )|^.*kill.*" +G $MAILLOG ${1+"$@"}
}

malias ()
{
	grep "alias[ 	]$*" $LOCAL/lib/mush/Mail.rc ${HOME}/.mushrc
}

signm ()
{
	grep "^#define[ 	]*SIG.*[ 	]*${1}[ 	]" ${SDKPREFIX}/usr/include/sys/signal.h
}

signo ()
{
	grep -i "^#define[ 	]*.*${1}[ 	]*[0-9]" ${SDKPREFIX}/usr/include/sys/signal.h
}

# _opers courtesy Rob Pike
#
C_opers ()
{
	cat <<__EOF__

1 () [] -> . left

2 ! ~ ++ -- - (type) * & sizeof right

3 * / % left

4 + - left

5 >> << left

6 < <= > >= left

7 == != left

8 & left

9 ^ left

10 | left

11 && left

12 || left

13 ?: right

14 = op= right

15 , left

__EOF__
}

Go_opers ()
{
	cat <<__EOF__

6             *  /  %  <<  >>  &  &^

5             +  -  |  ^

4             ==  !=  <  <=  >  >=

3             <-

2             &&

1             ||

__EOF__
}


# trivial hack to quickly search a source tree where traditional globbing would
# exceed ARG_MAX
#
# Requires a find with the SysVR4 "-exec ... {} ... +" feature.  (now also
# mandated by SUSv3, aka IEEE 1003.1-2001/2004)
#
# OpenGroup gives the following example of using this showing how arguments with
# whitespace, including newlines, are preserved:
#
#	find . ! -name . -prune -name '*.old' -exec \
#	    sh -c 'mv "$@" ../old/' sh {} +
#
# Following is a command which must succeed on any POSIX conformant system but
# which will fail if find lacks support for '+' due to a missing ';' argument,
# so could be used to detect incompatability and thus make it possible to
# provide an alternative implementation if desired:
#
#	find /dev/null -exec true '{}' +
#
# The most portable alternative might be to use 'sed' and 'xargs'.  Note the
# 'sed' command in the pipeline is mandatory.  Contrary to popular belief, xargs
# does NOT accept newline-delimited lists.  Rather it accepts shell-quoted
# lists, i.e. the input list is separated by whitespace and all internal
# whitespace must be quoted.  To avoid this the following command simply quotes
# _all_ characters with backslashes to satisfy this requirement, protecting
# embedded whitespace in filenames.
#
#	find ... | sed 's/./\\&/g' | xargs command
#
# The best alternative to the 'sed' is to use 'find -print0', but that still
# requires a pipeline to 'xargs', and it requires both a 'find' with '-print0'
# and an 'xargs' with '-0' (which are non-standard but nearly ubiquitous now)
# (i.e. to support printing and reading NUL separated values).
#
# Some versions of 'find' (notably on NetBSD) support '-printx' which does the
# backslash escaping directly itself, and as with the use of 'sed' shown above,
# 'xargs' supports this escaping by default (as per POSIX).  (It is indeed very
# weird that POSIX 'find' does not (yet) have the corresponding '-printx'.)
#
# So, this is the faster, standards-conformant, alternative to "find ... -print0
# | xargs -0 ..." or "find ... -printx | xargs ..."
#
srcfgrep ()
{
	# xxx maybe this should also ignore the "standard" set of compiler
	# outputs?  But those _should_ always be in a build or obj directory!
	# xxx not: -or -name dist -or -name 'dist-*' (these have source in NetBSD!)
	find . -type d \( -name CVS -or -name '.git*' -or -name .svn -or -name build -or -name 'build-*' -or -name autom4te.cache -or -name obj -or -name 'obj.*' \) -prune -or -type f ! -name '.#*' ! -name '#*#' ! -name '*~' ! -name '.*ignore' ! -name '[Tt][Aa][Gg][Ss]' -exec fgrep ${1+"$@"} {} +
}

sshsendkey ()
{
	# not all systems have ssh-copy-id(1)
	cat ${HOME}/.ssh/id_rsa.pub | ssh $1 '
		mkdir -pm 700 $HOME/.ssh
		cat >> $HOME/.ssh/authorized_keys
		chmod 600 $HOME/.ssh/authorized_keys
	'
}

# trim - remove any leading and trailing whitespace from a variable's value
#
# - using POSIX shell suffix/prefix pattern expansion
#
# xxx maybe this could also be called "crop" as it only crops whitespace at the
# beginning and end of the var's value?
#
# H.T. to Jarle Greipsland and RVP
#
trim ()
{
	local _var _val

	if [ $# -ne 1 -o -z "${1}" ] ; then
		echo "Usage: trim varname" >&2
		return 2
	fi

	_var="$1"
	eval _val=\"\${${_var}}\"

	# N.B.:  pdksh, including ksh(1) on NetBSD, does not yet implement
	# character classes for patterns thus the explicit whitespace.
	#
	#_val=${_val#${_val%%[![:blank:]]*}}
	#_val=${_val%${_val##*[![:blank:]]}}
	_val=${_val#${_val%%[!" 	"]*}}
	_val=${_val%${_val##*[!" 	"]}}

	eval ${_var}=\"\${_val}\"

	unset _var _val
}
#
# also e.g. to remove leading zeros from a variable:
#
#	v=${v#${v%%[!0]*}}
#	v=${v:-0}

# loopytrim - remove any leading and trailing whitespace from a variable's value
#
# Using shell patterns in a case statement, but one by one (simultaneously at
# each end) in a loop.  Probably more expensive than ${foo%${foo%%[[:blank:]]}}
# expansion in trim() above.
#
# [based on hints from kre on tech-toolchain@netbsd.org]
#
# This could also be called loopycrop as it only removes whitespace from the
# beginning and the end of the var's value.
#
loopytrim()
{
	local _var _val

	if [ $# -ne 1 -o -z "${1}" ] ; then
		echo "Usage: loopytrim varname" >&2
		return 2
	fi

	_var="$1"
	eval _val=\"\${${_var}}\"

	# N.B.:  pdksh, including ksh(1) on NetBSD, does not yet implement
	# character classes for patterns thus the explicit whitespace.
	#
	while case "${_val}" in
		#[[:blank:]]*)
		[" 	"]*)
			_val=${_val#?}
			;;
		#*[[:blank:]])
		*[" 	"])
			_val=${_val%?}
			;;
		*)
			break
			;;
		esac
	do :; done

	eval ${_var}=\"\${_val}\"

	unset _var _val
}

# trimfilter - remove leading, trailing, and inter-word whitespace
#
# xxx maybe this could be called "canonfilter"
#
trimfilter ()
{
	# AWK trickery to "canonicalize" whitespace in text.
	#
	# In AWK a pattern is an expression, and so just giving a non-zero value
	# says this expression matched, and if there's no action part to the
	# statement then the default action (if the pattern expression is true)
	# is to print the input line (i.e. $0), thus AWK can be cat:
	#
	#	awk 1
	#
	# The trick here is to re-assign the first field to itself -- this
	# causes AWK to rebuild the whole input line by first splitting it into
	# fields (with FS, space by default), then rebuilding $0 by putting the
	# fields back together using OFS (space by default).
	#
	# We put this together with two statements, the first with a missing
	# pattern (which always matches), and the second with a missing action
	# and a non-zero (i.e. "true") value as the pattern expression:
	#
	_USAGE="Usage: trimfilter [-F fs] [-v var=value] [file ...]"
	_HELP="${_USAGE}\n
		\t-F fs\t\tSet the input field separator FS to the regular expression fs.\n
		\t-v var=value\tAssign the value to the variable. (e.g. OFS=:)\n
		Trim is a wrapper on a small AWK program that splits and recombines all fields\n
		in each input line thus removing all leading and trailing whitespace (or the\n
		specified field separator value) and collapsing all whitespace (or FS) between\n
		each field."
	_awk_opts=
	OPTIND="1"
	while getopts "F:hv:" OPTCH
	do
		case ${OPTCH} in
		F|v)
			_awk_opts="${_awk_opts} -${OPTCH} '${OPTARG}'"
			;;
		h)
			echo ${_HELP}
			return 0
			;;
		*)
			echo ${_USAGE} >&2
			return 2
			;;
		esac
	done
	shift `expr ${OPTIND} - 1`

	eval awk ${_awk_opts} "'{\$1 = \$1};1'" ${1+"$@"}
	_rc=$?

	unset _USAGE _HELP _awk_opts OPTCH

	return ${_rc}
}

# search lint libraries for a function type declaration
#
typeof ()
{
	if [ -z "$LLIBDIR" ]; then
		if $ISSUN; then
			LLIBDIR=/usr/lib/lint
		elif [ -d /usr/libdata/lint ]; then
			# XXX not quite so useful when these are for xlint...
			LLIBDIR=/usr/libdata/lint
		else
			LLIBDIR=/usr/lib
		fi
	fi
	# should expand to allow '-l{lib}'
	egrep -i "$1" $LLIBDIR/llib-l*
}

if [ -n "$UUCPSPOOLDIR" ]; then
	# TODO: should only set this if "xtail" and UUCP are both actually available?
	uufollow ()
	{
		xtail $UUCPSPOOLDIR/.[AL]*/*
	}
fi
if [ -x /usr/ucb/rsh -a -x /bin/rsh ] ; then
	# /bin/rsh is likely the restricted shell!
	rsh ()
	{
		/usr/ucb/rsh ${1+"$@"}
	}
fi

if $ISSUN; then
	df ()
	{
		/usr/bin/df ${1+"$@"}
	}
fi

if [ `uname -s` = "Darwin" ]; then
        # N.B.  The OS product version can be found with /usr/bin/sw_vers

	# it's not the same, but it has similar uses...
	ldd ()
	{
		otool -L ${1+"$@"}
	}

	# macOS 'df' has a nasty bug in parsing its options and cannot see any
        # past the first '-t' (which is apparently deprecated and treated like
        # '-T' when given an argument), so be sure to use '-T'
	#
	df ()
	{
		local _Y

		if [ ]; then
			_Y="-Y,"
		fi
		/bin/df -P ${_Y} -T nonullfs ${1+"$@"} | fgrep -iv timemachine
		unset _Y
	}
fi

# delete all CONSECUTIVE blank lines from file except the first; also
# deletes all blank lines from top and end of file (emulates "cat -s")
# method 1, allows 0 blanks at top, 1 at EOF
# NOTE: never forget this -- it's the most incredible little sed script!!!!
blsqueeze ()
{
	sed '/./,/^$/!d' ${1+"$@"}
}

# (note: sh "read" command also reads backslash continued lines)
# XXX need an option to strip leading whitespace on continued lines
backslashjoin ()
{
	sed -e :a -e '/\\$/N; s/\\\n//; ta' ${1+"$@"}
}

# delete all CONSECUTIVE blank lines from file except the first; also
# deletes all blank lines from top and end of file (emulates "cat -s")
# method 1, allows 0 blanks at top, 1 at EOF
# NOTE: never forget this -- it's the most incredible little sed script!!!!
blsqueeze ()
{
	sed '/./,/^$/!d' ${1+"$@"}
}

# method 2, allows 1 blank at top, 0 at EOF
blsqueezebot ()
{
	sed '/^$/N;/\n$/D' ${1+"$@"}
}

# delete all CONSECUTIVE blank lines from file except the first 2:
blsqueezenot2 ()
{
	sed '/^$/N;/\n$/N;//D' ${1+"$@"}
}

# reverse order of lines (emulates "tac")
sed_tac ()
{
	sed '1!G;h;$!d' ${1+"$@"}
}

# reverse each character on the line (emulates "rev")
sed_rev ()
{
	sed '/\n/!G;s/\(.\)\(.*\n\)/&\2\1/;//D;s/.//' ${1+"$@"}
}

# join pairs of lines side-by-side (like "paste")
sed_paste ()
{
	sed 'N;s/\n/ /' ${1+"$@"}
}

# delete duplicate lines from a sorted file (emulates "uniq"). First
# line in a set of duplicate lines is kept, the rest are deleted
sed_uniq ()
{
	sed '$!N; /^\(.*\)\n\1$/!P; D' ${1+"$@"}
}


# delete ALL blank lines from a file (same as "grep '.' ")
blstrip ()
{
	sed "/./!d" ${1+"$@"}
}
blstrip2 ()
{
	sed '/^$/d' ${1+"$@"}
}

# delete all leading blank lines at top of file
blstriptop ()
{
	sed '/./,$!d'
}

# delete all trailing blank lines at end of file
blstripbot ()
{
	sed -e :a -e '/^\n*$/N;/\n$/ba'
}

ds ()
{
	$PAGER ${1+"$@"}
}
e ()
{
	${VISUAL:-$EDITOR} ${1+"$@"}
}
elc ()
{
	${MY_EMACS} -batch -q -no-site-file -f batch-byte-compile ${1+"$@"}
}
l ()
{
	${LS} -CF ${1+"$@"}
}
la ()
{
	${LS} -CFa ${1+"$@"}
}
lD ()
{
	${LS} -CFd ${1+"$@"}
}
lL ()
{
	${LS} -CFL ${1+"$@"}
}
ll ()
{
	${LS} -l${LS_O}s ${1+"$@"}
}
llD ()
{
	${LS} -l${LS_O}sd ${1+"$@"}
}
llL ()
{
	${LS} -l${LS_O}sL ${1+"$@"}
}
lla ()
{
	${LS} -l${LS_O}sa ${1+"$@"}
}
lli ()
{
	${LS} -li${LS_O}s ${1+"$@"}
}
llia ()
{
	${LS} -li${LS_O}sa ${1+"$@"}
}
llai ()
{
	${LS} -li${LS_O}sa ${1+"$@"}
}
llr ()
{
	${LS} -l${LS_O}sR ${1+"$@"}
}
llir ()
{
	${LS} -li${LS_O}sR ${1+"$@"}
}
llra ()
{
	${LS} -l${LS_O}saR ${1+"$@"}
}
llira ()
{
	${LS} -li${LS_O}saR ${1+"$@"}
}
lr ()
{
	${LS} -CFR ${1+"$@"}
}
lra ()
{
	${LS} -CFRa ${1+"$@"}
}
lsa ()
{
	${LS} -as ${1+"$@"}
}
lss ()
{
	${LS} -s ${1+"$@"}
}
nstty ()
{
	stty sane intr "^?" erase "^h" kill "^u" echoe echok
	echo "(use 'tput reset', or 'tabs -8' to reset tabs, etc.)"
}
rstty ()
{
	stty $SANE
	echo "(use 'tput reset', and/or 'tabs -8' to reset tabs, etc.)"
}
wcvs ()
{
	echo $CVSROOT
}

netbsd_query_pr ()
{
	local argv0="netbsd-query-pr"
	local USAGE="usage: $argv0 PR_NUMBER"
	local PR PR_URL BROWSER BROWSER_ARGS

	if [ $# -ne 1 ]; then
		echo $USAGE 1>&2
		return 2
	fi
	PR=$1
	PR=${PR#*/}
	PR=${PR#"pr#"}
	PR=${PR#"PR#"}
	PR=${PR#"pr"}
	PR=${PR#"PR"}

	if [ "${PR}" -eq "${PR}" 2>/dev/null ] ; then
		PR_URL="http://gnats.NetBSD.org/${PR}"
	else
		echo "$argv0: parameter MUST be a valid PR number." 1>&2
		usage
		return 2
	fi

	if [ -n "$DISPLAY" ]; then
		BROWSER="links"
		BROWSER_ARGS="-g"
	else
		case "$LC_CTYPE" in
		*[Uu][Tt][Ff]*)
			BROWSER="elinks"
			BROWSER_ARGS=""
			;;
		*)
			BROWSER="links"
			BROWSER_ARGS=""
			;;
		esac
	fi

	$BROWSER $BROWSER_ARGS "$PR_URL"
}

# N.B.:  this definition is used by ~/.*shrc files to test if this file should
# be sourced....  Do not remove it without updating them!
#
zhead ()
{
	zcat ${1+"$@"} | head
}

# done....
